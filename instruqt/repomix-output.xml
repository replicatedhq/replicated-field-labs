This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: {distributing-with-replicated,avoiding-installation-pitfalls,closing-information-gap,protecting-your-assets,delivering-as-an-appliance}/**/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
avoiding-installation-pitfalls/
  01-working-with-preflight-checks/
    assignment.md
  02-checking-cluster-resources/
    assignment.md
  03-adding-preflights-to-the-chart/
    assignment.md
  04-releasing-the-application/
    assignment.md
  05-validating-before-an-install/
    assignment.md
  06-completing-the-install/
    assignment.md
closing-information-gap/
  01-viewing-instance-info/
    assignment.md
  02-working-with-support-bundles/
    assignment.md
  03-additional-information/
    assignment.md
  04-adding-to-the-chart/
    assignment.md
  05-releasing-an-update/
    assignment.md
  06-support-bundle-diagnosis/
    assignment.md
  07-other-ways/
    assignment.md
delivering-as-an-appliance/
  01-specifying-the-cluster/
    assignment.md
  02-customize-for-your-app/
    assignment.md
  03-collecting-configuration/
    assignment.md
  04-using-the-configuration/
    assignment.md
  05-downloading-and-installing/
    assignment.md
  06-completing-the-install/
    assignment.md
distributing-with-replicated/
  01-preparing-to-use-the-sdk/
    assignment.md
  02-enabling-the-sdk/
    assignment.md
  03-creating-a-release/
    assignment.md
  04-installing-the-application/
    assignment.md
  05-validating-the-install/
    assignment.md
protecting-your-assets/
  01-the-replicated-license/
    assignment.md
  02-create-a-customer/
    assignment.md
  03-proxying-private-images/
    assignment.md
  04-helm-values-for-license-fields/
    assignment.md
  05-license-entitlements/
    assignment.md
  06-validating-license-fields/
    assignment.md
  07-entitlement-metrics/
    assignment.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="avoiding-installation-pitfalls/01-working-with-preflight-checks/assignment.md">
---
slug: working-with-preflight-checks
id: pb1gr26u3om3
type: challenge
title: Working with Preflight Checks
teaser: |-
  Learn how preflight checks help you avoid common install
  mistakes
notes:
- type: text
  contents: Let's learn about Preflights
tabs:
- id: mrf6knj0wyfn
  title: Shell
  type: terminal
  hostname: shell
- id: xze3brnl78ss
  title: Manifest Editor
  type: code
  hostname: shell
  path: /home
difficulty: basic
timelimit: 300
---

👋 Introduction
===============

One of the areas teams worry about most when distributing software
to customer clusters is whether those clusters will be properly
configured for the application to run. To address this challenge,
the Replicated Platform provides for the implementation and
management of preflight checks that can describe your expectations
and validate them. Preflights are part of the
[Troubleshoot](https://troubleshoot.sh) open source project.

What is a Preflight Check?
===========================

Preflight checks analyze your customer's cluster as a client without
installing anything into it. This allows customers to run Preflight
checks at any time before installing your software, and keep the
cluster unchanged. They codify the pre-requisites you would catalog
in your documentation and make them executable.

You define your checks in a YAML file that follows the same format
as a Kubernetes object. The simplest preflight object looks like this,
and it's in the file `empty-preflights.yaml`:

```
apiVersion: troubleshoot.sh/v1beta2
kind: Preflight
metadata:
  name: empty-preflight-checks
spec:
  analyzers: []
```

As the name `empty-preflight-checks` suggests, this is an empty set
of checks and will not execute. Let's try it out.

```
kubectl preflight ./empty-preflights.yaml
```

You'll get a warning/error, since there needs to be at least one analyzer
defined in order to check the cluster.

```
Warning: No analyzers found
```

Analyzers and Collectors
========================

Preflight checks are made up of two types of objects, _collectors_
that collect data from the cluster, and _analyzers_ that analyze
the collected data. Many preflight definitions do not specify any
collectors, since two collectors are included in all preflights
by default.

The `clusterInfo` collector collects information about the running
cluster, like the Kubernetes version and other info you'd see when
running `kubectl version`. The other default collector is
`clusterResources`, which collects information about resources of
several known types across all namespaces that the user has
access to. You can also add custom collectors, which we'll look
at later in the lab.

The majority of your work on preflight checks will be with
analyzers that validate your requirements. A very common analyzer
is to check that the cluster is running a supported version of
Kubernetes.

```
apiVersion: troubleshoot.sh/v1beta2
kind: Preflight
metadata:
  name: slackernews-preflight-checks
spec:
  analyzers:
    - clusterVersion:
        outcomes:
          - fail:
              when: "<= 1.26.x"
              message: |-
                Your Kubernets cluster is running a version of Kubernetes that is no longer supported by the Kubernetes
                community and unable to be supported by Slackernews. Changes in Kubernetse since your current version mean
                that you installation will likely not succeed. Please upgrade your cluster or install to a different
                cluster running at least Kubernetes 1.26, ideally version 1.28.0 or later.

                If you are receiving extended support from your Kubernetes provider you may be able to ignore
                this warning. If not, we recomend that you upgrade your cluster to at least version 1.28.0.

              uri: https://kubernetes.io
          - warn:
              when: "< 1.27.0"
              message: |-
                Your Kubernetes cluster is running a version of Kubernetes that will go out of support active support in
                less than six months. We recommend that you upgrade your Kubernetes cluster to assure continued success with
                your Slackernews implementation.
              uri: https://kubernetes.io
          - pass:
              message: Your cluster is running a version of Kubernetes that is supported by Slackernews.
```

This analyzer is the first of a handful of analyzers we will add in this lab.

Getting Started
===============

Let's start by creating a new file for a simple set of  preflight checks in our
home directory. using the Kubernetes cluster version example above. Click on
the "Manifest Editor" tab and create a new file named
`slackernews-preflights.yaml`.

![Creating the Preflights File](../assets/creating-slackernews-preflights.png)

Paste the YAML above into the new file and the editor will automatically save it.

![Saving the Preflight File](../assets/saving-slackernews-preflights.png)

Now let's run our preflight checks.

```
kubectl preflight ./slackernews-preflights.yaml
```

You'll see that your check has been run and it should report
that it has passed with a supported version of Kubernetes.

![Passing Kubernetes Version Preflight Check](../assets/passing-version-check.png)
</file>

<file path="avoiding-installation-pitfalls/02-checking-cluster-resources/assignment.md">
---
slug: checking-cluster-resources
id: jn3ywr8xtchw
type: challenge
title: Checking Cluster Resources
teaser: Use preflight checks to validate minimum cluster requirements
notes:
- type: text
  contents: Making sure a cluster has sufficient resources to run your application
tabs:
- id: tkmoixrrxpfp
  title: Shell
  type: terminal
  hostname: shell
- id: qorzyzbpqu6g
  title: Manifest Editor
  type: code
  hostname: shell
  path: /home/replicant
difficulty: basic
timelimit: 300
---

Now that we know we're installing to a supported version of
Kubernetes, let's see if that cluster has the resources to
support running Slackernews.

Cluster Resources
=================

The default `clusterResources` collector collects information
about all of the nodes in the cluster. This allows us to
write analyzers that check whether the cluster has sufficient
resources to run our application: most often we write checks to
determine whether CPU, memory, and storage meet the base
requirements of the application.

When analyzing resources in the cluster, we can write expressions
based on whether the node has the
[capacity required and whether that capacity is allocatable](https://kubernetes.io/docs/concepts/architecture/nodes/#capacity).
Allocatable has a very specific meaning in Kubernetes, and is not
the same as "free" or "available". It means only that the capacity
is not being reserved by Kubernetes or the underlying system. This
distinction often trips up developers who are new to Kubernetes.

Verify Resource Requirements
============================

The best way to define your preflight checks for cluster resources
is to make sure they align with your documentation for the minimum
and recommended values. The preflight check makes those prerequisites
executable and lets your customer know whether their install will
succeed. Let's look at [Slackernews's documentation](https://goslackernews.io/docs/2.8.0/install-config/installation-prereqs/)
for guidance on our preflights.

<table>
<thead>
<tr>
<th>Resource</th>
<th>Minimum</th>
<th>Recommended</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>2 CPU</td>
<td>4 CPU</td>
</tr>
<tr>
<td>Mem</td>
<td>4 GB</td>
<td>8 GB</td>
</tr>
</tbody>
</table>

Since we have both recommended and minimum values, we have thresholds
for both warning and failure. Let's add the CPU check into our
`slackernews-preflights.yaml` manifest. Open up the "Manifest Editor" tab
and paste this new analyzer after the one checking the Kubernetes version.

```
    - nodeResources:
        checkName: Cluster CPU resources are sufficient to install and run Slackernews
        outcomes:
          - fail:
              when: "sum(cpuAllocatable) < 2"
              message: |-
                Slackernews requires a minimum of 2 CPU cores in order to run, and runs best with
                at least 4 cores. Your current cluster has less than 2 CPU cores available to Kubernetes
                workloads. Please increase cluster capacity or install into a different cluster.
              uri: https://goslackernews.io/docs/2.8.0/install-config/installation-prereqs/
          - warn:
              when: "sum(cpuAllocatable) < 4"
              message: |-
                Slackernews runs best with a minimum of 4 CPU cores. Your current cluster has less
                than 4 CPU cores available to run workloads. For the best experience, consider
                increasing cluster capacity or installing into a different cluster.
              uri: https://goslackernews.io/docs/2.8.0/install-config/installation-prereqs/
          - pass:
              message: Your cluster has sufficient CPU resources available to run Slackernews
```

After saving your changes run the preflight checks command to see the outcome.

```
kubectl preflight ./slackernews-preflights.yaml
```

You'll see that our cluster generates a warning since it has only two CPU
cores available. This should be fine for our lab environment, so we can
ignore the warning for now.

![CPU Preflight Warning](../assets/cpu-preflight-warning.png)

To round out the resource checks, add a similar check for memory. It should
also show a warning which is fine for the lab environment.

```
    - nodeResources:
        checkName: Cluster memory is sufficient to install and run Slackernews
        outcomes:
          - fail:
              when: "sum(memoryAllocatable) < 4G"
              message: |-
                Slackernews requires a minimum of 4 GB of memory in order to run, and runs best with
                at least 8 GB. Your current cluster has less than 4 GB available to Kubernetes
                workloads. Please increase cluster capacity or install into a different cluster.
              uri: https://goslackernews.io/docs/2.8.0/install-config/installation-prereqs/
          - warn:
              when: "sum(memoryAllocatable) < 8Gi"
              message: |-
                Slackernews runs best with a minimum of 8 GB of memory. Your current cluster has less
                than 8 GB of memory available to run workloads. For the best experience, consider
                increasing cluster capacity or installing into a different cluster.
              uri: https://goslackernews.io/docs/2.8.0/install-config/installation-prereqs/
          - pass:
              message: Your cluster has sufficient memory available to run Slackernews
```

Running the Revised Preflights
==============================

Now that we have a thorough set of preflights for cluster resources, let's run
them:

```
kubectl preflight ./slackernews-preflights.yaml
```

You'll see that all three preflights are run, and that the memory
preflight has warned you. This is an expected failure, since we have
single node cluster that has a small memory footprint.

![Memory Preflight Warning](../assets/memory-preflight-failure.png)

If you completed the [Distributing Your Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-your-application-with-replicated)
lab, you may be surprised at this failure. In that lab, we deployed Slackernews
and it came up successfully.

Catching those types of surprises _before_ they become issues is a big reason
to use preflight checks. By detecting latent failures, they help your customers
make adjustments ahead of time. Slackernews could exhaust the memory
available in this cluster even though it started successfully.
</file>

<file path="avoiding-installation-pitfalls/03-adding-preflights-to-the-chart/assignment.md">
---
slug: adding-preflights-to-the-chart
id: dxquyvsyuojv
type: challenge
title: Adding Preflights to the Slackernews Helm Chart
teaser: Learn how to incorporate your preflight checks into your chart
notes:
- type: text
  contents: Time to add our preflight checks to the Slackernews Helm chart
tabs:
- id: 8jjygkef146j
  title: Shell
  type: terminal
  hostname: shell
- id: bjyujpl2opc6
  title: Manifest Editor
  type: code
  hostname: shell
  path: /home/replicant
difficulty: basic
timelimit: 600
---

There are many more preflight checks we could define for
Slackernews, but let's stop here and shift to how we can
deliver these checks as part of the application. To do this,
we're going to incorporate them into our Helm chart and
release a new version using the Replicated Platform.

Making Preflights Available with Your Application
=================================================

We defined our preflight checks in a manifest that looks a lot like a
Kubernetes resource. It's useful to think of it as one, since it's an important
part of successfully distributing and supporting an application. But it's
different in one important way: it's not processed by the Kubernetes API but
instead by the open source [Troubleshoot tooling](https://troubleshoot.sh).

To accommodate this distinction, but still make it available
as part of our Helm chart, we are going to store it in a
Kubernetes secret that our chart creates. This helps us in
two ways:

1. We won't try to create a resource the cluster doesn't
   know about.
2. It's available in the cluster as part of the application
   for the customer to run at any time.

We identify this secret with a label that we add to the
secret when we incorporate it into our chart.

```
troubleshoot.sh/kind: preflight
```

If we consider the "simplest possible" preflight spec from
the first step in the lab, it would become a secret that
looks like this:

```
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: empty-preflights
  labels:
    troubleshoot.sh/kind: preflight
stringData:
  preflight.yaml: |-
    apiVersion: troubleshoot.sh/v1beta2
    kind: Preflight
    metadata:
      name: empty-preflight-checks
    spec:
      analyzers: []
```

To run it, we can use the `preflight` plugin to `kubectl`
like we did before

```
kubectl preflight ./empty-preflight-secret.yaml
```

Remember that this preflight check won't run successfully
since we haven't defined any analyzers to check anything.

```
Error: no results
```

_Note: The preflight check can also be stored as a `ConfigMap`
with the same annotation._

Adding Preflight Checks into the Slackernews Helm Chart
==================================================

Now that you know how to include your preflight checks into a
Helm chart, let's add them to the Slackernews Helm chart. To make
the secret fit in with Bitnami's naming, labeling, and annotation
conventions, there's a little bit of boiler plate required. You'll
likely need to do something similar to follow your team's
conventions when working with your own chart.

Similarly, we're going to follow the conventions for the Slackernews chart where
different components are in their own directories and create a directory to
store our preflight chart in. We're going to call the directory `troubleshoot`
since preflight checks are one of two types troubleshooting resources provided
by the Replicated Platform. Create the directory from the shell.

```
mkdir slackernews/templates/troubleshoot
```

Open the manifest editor and create a new file named `preflights.yaml` in the
directory `slackernews/templates/troubleshoot`. This will be the template that
creates the preflight secret when the Helm chart is installed.

![Creating the Preflights Template](../assets/creating-the-preflights-template.png)

After creating the file, click on the filename
to make sure it is opened.

Add the following to the file. As noted above, there's a lot of
templating to make sure naming, labels, and annotations are
consistent. If you look beyond that, we're really just creating a
secret that will have some string data at the key `preflight.yaml`.
Also note the label `troubleshoot.sh/kind: preflight` which
identifies the secret for the `preflight` command.

```
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "slackernews.name" . }}-preflight
  namespace: {{ .Release.Namespace | quote }}
  labels: {{- include "slackernews.labels" . | nindent 4 }}
    app.kubernetes.io/component: preflight
    troubleshoot.sh/kind: preflight
type: Opaque
stringData:
  preflight.yaml: |
```

The template is ready for you to add the preflight checks we
created in the previous step. Paste them in and make sure
the indentation is correct.

```
    apiVersion: troubleshoot.sh/v1beta2
    kind: Preflight
    metadata:
      name: slackernews-preflight-checks
    spec:
      analyzers:
        - clusterVersion:
            outcomes:
              - fail:
                  when: "<= 1.26.x"
                  message: |-
                    Your Kubernets cluster is running a version of Kubernetes that is no longer supported by the Kubernetes
                    community and unable to be supported by Slackernews. Changes in Kubernetse since your current version mean
                    that you installation will likely not succeed. Please upgrade your cluster or install to a different
                    cluster running at least Kubernetes 1.26, ideally version 1.28.0 or later.

                    If you are receiving extended support from your Kubernetes provider you may be able to ignore
                    this warning. If not, we recomend that you upgrade your cluster to at least version 1.28.0.

                  uri: https://kubernetes.io
              - warn:
                  when: "< 1.27.0"
                  message: |-
                    Your Kubernetes cluster is running a version of Kubernetes that will go out of support active support in
                    less than six months. We recommend that you upgrade your Kubernetes cluster to assure continued success with
                    your Slackernews implementation.
                  uri: https://kubernetes.io
              - pass:
                  message: Your cluster is running a version of Kubernetes that is supported by Slackernews.
        - nodeResources:
            checkName: Cluster CPU resources are sufficient to install and run Slackernews
            outcomes:
              - fail:
                  when: "sum(cpuAllocatable) < 2"
                  message: |-
                    Slackernews requires a minimum of 2 CPU cores in order to run, and runs best with
                    at least 4 cores. Your current cluster has less than 2 CPU cores available to Kubernetes
                    workloads. Please increase cluster capacity or install into a different cluster.
              - warn:
                  when: "sum(cpuAllocatable) < 4"
                  message: |-
                    Slackernews runs best with a minimum of 4 CPU cores. Your current cluster has less
                    than 4 CPU cores available to run workloads. For the best experience, consider
                    increasing cluster capacity or installing into a different cluster.
              - pass:
                  message: Your cluster has sufficient CPU resources available to run Slackernews
        - nodeResources:
            checkName: Cluster memory is sufficient to install and run Slackernews
            outcomes:
              - fail:
                  when: "sum(memoryAllocatable) < 4G"
                  message: |-
                    Slackernews requires a minimum of 4 GB of memory in order to run, and runs best with
                    at least 8 GB. Your current cluster has less than 4 GB available to Kubernetes
                    workloads. Please increase cluster capacity or install into a different cluster.
              - warn:
                  when: "sum(memoryAllocatable) < 8Gi"
                  message: |-
                    Slackernews runs best with a minimum of 8 GB of memory. Your current cluster has less
                    than 8 GB of memory available to run workloads. For the best experience, consider
                    increasing cluster capacity or installing into a different cluster.
              - pass:
                  message: Your cluster has sufficient memory available to run Slackernews
```

After you make your changes, the editor will auto-save.

![Saving the Preflights Template](../assets/saving-the-preflights-template.png)

Testing and Repackaging Your Chart
==================================

You can test out your changes by templating out your Helm chart and
piping the results to `kubectl preflight`. This is how your customers
will run the checks from your released chart as well.

```
helm template slackernews | kubectl preflight -
```

If you're satisfied with the tests, bump the version of your Helm chart in the file
`slackernews/Chart.yaml` from `0.2.0` to `0.3.0`, then repackage it. You can edit
the version in the Manifest Editor or run the following command to do it from
the shell:

```
yq -i '.version = "0.3.0"' slackernews/Chart.yaml
```

Then run the `helm package` command to package the updated version:

```
helm package slackernews --destination ./release
```
</file>

<file path="avoiding-installation-pitfalls/04-releasing-the-application/assignment.md">
---
slug: releasing-the-application
id: atrybjwrgxfh
type: challenge
title: Releasing the Application
teaser: Releasing with preflights on the Replicated Platform
notes:
- type: text
  contents: Time to release an update with our preflight checks
tabs:
- id: hue1wtnboudc
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 300
---

Since we're distributing our application with the Replicated
Platform, we need to let the platform know about the changes
we've made to the application by creating a new release. This
process will be familiar to you if you have completed
the [Distributing Your Application with Replicated](https://play.instruqt.com/replicated/tracks/distributing-your-application-with-replicated)
lab. If not, you may want to go through that lab to learn a bit
more about how releases and release channels work.

A Quick Look at Release Channels
================================

The Replicated Platform provides a way to connect
each customer to the right release(s) for them. It does this
by organizing releases into _channels_, and assigning each
customer license to the appropriate channel. Release channels
help you account for these different release cadences for
your software.

By default, Replicated creates three release channels for
each application: `Unstable`, `Beta`, and `Stable`. We're
going to release our updates to Slackernews across all three of
those channels.

Preparing to Release
====================

Before we release, we need to make sure we're authenticated
to the Replicated Platform. We're going to use an API
token to do that. The lab setup created one for you. Let's
set it in an environment variable.


```
export REPLICATED_API_TOKEN="[[ Instruqt-Var key="REPLICATED_API_TOKEN" hostname="shell" ]]"
```

We also need to tell the `replicated` command which
application to work with. We can do this with every command,
but it's easier to just set an environment variable.

```
export REPLICATED_APP="[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]"
```

Creating a New Release
======================

There are two releases already available for the Slackernews
application. We're going to release a third that includes
the preflight checks.

```
replicated release ls
```

You'll see that the the same release is current across
all three channels, and it has the sequence number `1`.
All releases are assigned a sequence number based on the
order in which they were created.

```
SEQUENCE    CREATED                 EDITED                  ACTIVE_CHANNELS
1           2023-06-08T00:23:40Z    0001-01-01T00:00:00Z    Stable,Beta,Unstable
```

To release our new version, we create a new release and
(optionally) assign it to a channel. It's a good practice
to make new releases on either the `Unstable` channel or
a channel specific to the feature you are working on. Let's
use the `Unstable` channel for this lab, since the latter
approach is best for teams working with feature branches.

```
replicated release create --promote Unstable --chart ./release/slackernews-0.3.0.tgz --version 0.3.0  \
  --release-notes "Adds preflight checks to enable customers to validate cluster prerequisites before installing"
```

This creates a release for version `0.3.0` of the Slackernews Helm
chart, and promotes it to the `Unstable` channel. The `create`
command output a sequence number that you'll need for `promote` (it
will be `2` if you haven't explored releasing a bit more).

```
  _ Reading manifests from ./release _
  _ Creating Release _
    _ SEQUENCE: 2
  _ Promoting _
    _ Channel 2Qa7rGeBiT3DaDK85s6FVKRC7Mn successfully set to release 2
```

For the lab, we're going to assume this release can be directly
shared on the `Beta` and `Stable` channels. Your actual release
process may have many more activities before releasing to either
of those channels---your teams review and approval processes,
steps in a continuous delivery pipeline, or both. Run the following command to promote our release to the `Beta` channel:

```
replicated release promote 2 Beta --version 0.3.0 \
  --release-notes "Adds preflight checks to enable customers to validate cluster prerequisites before installing"
```

Then promote to the `Stable` channel:

```
replicated release promote 2 Stable --version 0.3.0 \
  --release-notes "Adds preflight checks to enable customers to validate cluster prerequisites before installing"
```

List your releases again to see that the release has been
promoted.

```
replicated release ls
```

Your list of releases will now show three releases with the third
release available on the `Unstable`, `Beta`, and `Unstable` channels.

```
SEQUENCE    CREATED                 EDITED                  ACTIVE_CHANNELS
2           2023-06-10T20:22:14Z    0001-01-01T00:00:00Z    Stable,Beta,Unstable
1           2023-06-10T20:20:02Z    0001-01-01T00:00:00Z
```
</file>

<file path="avoiding-installation-pitfalls/05-validating-before-an-install/assignment.md">
---
slug: validating-before-an-install
id: bxilvoxbkmfz
type: challenge
title: Validating Before an Install
teaser: How your customer uses preflights to validate their environment
notes:
- type: text
  contents: Experience how your customer executes your preflight checks
tabs:
- id: rszt3nfzheah
  title: Shell
  type: terminal
  hostname: shell
- id: 8hyv0jpufvyq
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 600
---

Having a release with your preflights included means you can
take advantage of the Replicated Platform to distribute those
preflights. The entitlements that provide access to your
application control access to the preflight checks as well.
To run the preflights, your customer templates out your
Helm chart and pipes the output to the `preflight` plugin
to `kubectl`, just like you did to test your changes.

Logging Into the Vendor Portal
==============================

To run the preflights as a customer, we need to have their
login credentials to the Replicated registry. The lab set up
process configured a customer for the Slackernews application,
but in this step we're going to add a new customer. We'll
do this in the Replicated Vendor Portal.

Click on the Vendor Portal tab to open up a new browser window and
access the portal. Log in with these credentials:

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

You'll land on the "Channels" page for your app, which will show
the release channels we discussed in the previous step. Notice that
each of the default channels shows the current version `0.3.0`,
while the channel LTS, which we haven't released to, reflects
that.

![Vendor Portal Release Channels](../assets/vendor-portal-landing.png)

Creating a Customer
===================

To create a customer, select "Customers" from the menu on the left,
then click the "+ Create Customer" button.

![Creating a Customer](../assets/create-customer-button.png)

Call your customer "Geeglo" and assign them to the `Stable` channel.
Let's assume this customer is not yet a customer, but a prospect who
is evaluating our application. Let's allow our customer to
evaluate our software on a trial license for 30 days.  Set them up
as a "Trial" customer and set up the expiration date and customer
email as follows:

Expiration Date: `[[ Instruqt-Var key="LICENSE_EXPIRY" hostname="shell" ]]`<br/>
Customer Email: `[[ Instruqt-Var key="CUSTOMER_EMAIL" hostname="shell" ]]`<br/>
Install Type: "Existing Cluster (Helm CLI)"

![Customer Details](../assets/new-customer-details.png)

Running Preflight Checks
========================

Your customer will prepare for their installation by running
the preflights checks. Since the preflights are embedded in
the Slackernews Helm chart, they first need to log into the Replicated
registry with the `helm` command. This gives them access to
your Helm chart via the Replicated Platform.

If you completed the [Distributing Your Application with Replicated](https://play.instruqt.com/replicated/tracks/distributing-your-application-with-replicated)
lab, you'll remember that each customer has their own login
credentials that are specific to their entitlements to your
application. You can get those instructions by clicking the
"Helm Install Instructions" button on the customer page.

![Install instruction](../assets/install-instructions.png)

In this lab, we only want to execute the first step in the process,
which is to log into the registry. Because you just created
the customer, you'll have to copy the login command from the
customer page.

From there, they can use the `helm template` command to extract the
preflight checks to run with `kubectl preflight`.

```
helm template oci://registry.replicated.com/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews \
  | kubectl preflight -
```

Running the checks this way shows them the same screen you saw when
you tested the preflights earlier, with the Kubernetes version check
passing, the memory check failing, and a warning for the CPU available.

![Customer Preflight Checks](../assets/customer-preflight-checks-before.png)

To have a successful installation, the customer has to make a decision
about whether they should install to a different cluster or add
more resources to this cluster.
</file>

<file path="avoiding-installation-pitfalls/06-completing-the-install/assignment.md">
---
slug: completing-the-install
id: zwojuzyxhzsq
type: challenge
title: Completing the Install
teaser: Finishing the install once the cluster passes its preflights
notes:
- type: text
  contents: Completing the installation when cluster capacity is increased
tabs:
- id: hvpbi534iipc
  title: Shell
  type: terminal
  hostname: shell
- id: so6uwiwpvwam
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
- id: 8f7zxmrg2vcw
  title: Slackernews
  type: service
  hostname: cluster
  port: 30443
  new_window: true
difficulty: basic
timelimit: 600
---

We're going to continue playing the role of the customer
who had a failing preflight check for Slackernews.
Let's also assume that the customer decided to increase
the capacity of the cluster and is ready to perform
the installation.

Validating the Added Capacity
=============================

The first step to resuming the installation process is
to make sure that the cluster has been upgraded with the
necessary resources. We can do that by re-running the
preflight checks against the now expanded cluster.

```
helm template oci://registry.replicated.com/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews \
  | kubectl preflight -
```

In the background, the lab setup process added two
additional nodes to the cluster so that the memory
and CPU capacity has increased. The results of the
checks confirm this change.

![Customer Cluster is Ready for Install](../assets/customer-preflight-checks-after.png)

Installing the Application
==========================

Now that the preflight checks have passed, it is safe to install the
application. You can find the installation command for the customer "Geeglo" in
the Replicated Vendor Portal. Since we've already run the first two steps of
logging into the registry and running our preflight checks, we have only the
installation with the Helm command to complete.

You can use the Vendor Portal tab to look up the install instruction, just like
you did in the previous step before running the preflights. Click "Customers"
in the left navigation, then click on "Geeglo". You access the instructions
using the "Helm Install Instructions" button on the top right.

![Customer Installation Commands](../assets/install-instructions.png)

Make sure you're logged into the Registry as the customer you created using the
first command.

```
helm registry login [[ Instruqt-Var key="REGISTRY_HOST" hostname="shell" ]] \
    --username [[ Instruqt-Var key="REGISTRY_USERNAME" hostname="shell" ]] \
    --password [[ Instruqt-Var key="REGISTRY_PASSWORD" hostname="shell" ]]
```

The last command is the install command, but we can't use it directly. We need
to add some additional values that Slackernews needs to come up correctly. This
helps us make sure the installation will complete.

```
helm install --namespace slackernews --create-namespace  \
    slackernews \
    oci://[[Instruqt-Var key="REGISTRY_HOST" hostname="shell" ]]/[[Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews \
    --set nginx.service.type=NodePort --set nginx.service.nodePort.port=30443 \
    --set slackernews.domain=[[ Instruqt-Var key="SLACKERNEWS_DOMAIN" hostname="cluster" ]] \
    --set service.type=NodePort
```

Note that the cluster we're using is fairly limited, so we're using `NodePort`
to simplify access.

Verifying the Installation
==========================

From the customer perspective, the installation is complete when they can log
into the application and see that it was complete. Once their install is
complete, the tab "Slackernews" should show the login page for Slackernews.

![Slackernews Landing Page](../assets/slackernews.png)

🏁 Finish
=========

You've now successfully seen how you can provide preflight checks to your
customer to help them avoid potential pitfalls installing your application.
You've also seen how those preflights can help your customer understand what
they need to do to prepare for an install, and how they can complete a
successful install once the preflight checks pass.
</file>

<file path="closing-information-gap/01-viewing-instance-info/assignment.md">
---
slug: viewing-instance-info
id: b8a1bj7ffosj
type: challenge
title: Getting a Picture of a Customer Instance
teaser: Using the Replicated Platform to understand details of a customer instance
notes:
- type: text
  contents: Establish instant context when a support request comes in
tabs:
- id: njr2qrhr1amp
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 600
---


👋 Introduction
===============

When your software is running in a customer cluster, you no longer have direct
access to the cluster to troubleshoot when things go wrong. You won't be able
to see what's running, read logs, or even confirm that the instance ever
started up. Your customer can do these things, but they may need your guidance
to do them correctly. Coordinating that information sharing can be
challenging.

In this lab, we're going to use Slackernews as a substitute for your
application and assume we have two customers "Omozan" and "Geeglo" that are
running the application. Geeglo has submitted a support ticket to your team and
you have been assigned to help them resolve it.


Observing a Customer Instance
===============================

The Replicated Platform provides a feature called Instance Insights that
collects and interprets telemetry information from your application. It's
enabled automatically when you incorporate the Replicated SDK into your
application. The insights provided include the version of your application the
customer is running, details about the cluster, and current instance health.

The starting point for any support ticket should be to log into the
Replicated Vendor Portal to look at the details on the customer's instance.
Click on the Vendor Portal tab to open up a new browser window and access the
portal. The labs setup has configure credentials for you that you can use to
log in.

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

We're going to log into the portal and take a look at Geeglo's instance to get
some context on their instance. Once you log in, you'll land on a page showing
the release channels for your applications. Release channels connect each of
your customers to the appropriate stream of releases. You can learn more about
release channels in the [Distributing Your Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-with-replicated)
lab.

![Vendor Portal Landing Page with Release Channels](../assets/vendor-portal-landing.png)

Select the "Customers" link from the left navigation to go see a list of
customers.

![Customers Landing Page with Geeglo Showing an Unavailable Instance](../assets/customers-page.png)

You'll see that Geeglo, who submitted the support ticket, has one instance and
that it is currently unavailable. You can click on the identifier for that
instance to see more details about it.

![Geeglo Instance Details with Uptime Graph and Events](../assets/geeglo-outage.png)

Reviewing the Instance
======================

The instance details will give you a lot information to help you engage with
Geeglo on their support ticket:

* A general overview of how stable this instance has been from from the uptime
  graph. You can change the timeline of the graph to gain more insight.
* The current version of your application they are running, and how long that
  version has been installed. You can also see at a glance if it's the current
  version or if they have fallen behind.
* What type of Kubernetes cluster they are running on, what version of
  Kubernetes it is, and details about the cloud environment it's running in.
* Details about their license and which release channel they are assigned to.

You also see a stream of events come from their cluster. The events can help
you reconstruct the history of their instance in terms of installation,
upgrades, availability, and some changes to the infrastructure (like changing
Kubernetes versions or distributions).

You can filter the list of events using the "Filter activity" button.

![Filter Options for Instance Activity](../assets/event-filters.png)

Instance Activity
=================

Different types of activity can help you understand the state of the customer
instance in order to more quickly resolve their issues.

<table>
<thead>
<tr>
<th>Activity Type</th>
<th>Information Available<th>
</tr>
</thead>
<tbody>
<tr>
<td>Application Installation and Upgrade Events</td><td>These events tell you when the instance was installed or upgraded. They include information about the status of the application, the channel the release came from, and the version of the release. Possible statuses are <em>Ready</em>, <em>Updating</em>, <em>Degraded</em>, <em>Unavailable</em>, or <em>Missing</em>. Status is based on the ready state of various application resources.</td>
</tr>
<tr>
<td>App status</td><td>Show changes to the application status outside of installation and upgrades. These events will show the same statuses as the install and upgrade events.</td>
</tr>
<tr>
<td>Cluster status</td><td>Provide details on the cluster running the application. You'll see events related to the Kubernetes distribution and it's version. If the cluster is a Replicated embedded Kubernetes cluster that you provided with your application there will be additional information about the number of nodes, their status, and the specification the cluster was built from. Currently the Kubernetes distribution is identified if it is EKS, GKE, K3s, or RKE.</td>
</tr>
<tr>
<td>Infrastructure status</td><td>Share details about the underlying cloud infrastructure where the cluster is running. Currently limited to showing information about AWS, GCP, and Digital Ocean. These events show the cloud provider and the region.</td>
</tr>
<tr>
<td>Replicated status</td><td>These events let you know the version of the Replicated SDK or Replicated KOTS that the instance is running. For this lab, the application is using the Replicated SDK.</td>
</tr>
<tr>
<td>Upstream update</td><td>Let you know when you released new updates on the release channel the instance is assigned to. Shows events when a new version is released including the version label and the number of versions behind that the instance is running. The number of versions behind may be zero, if the instance is up-to-date.</td>
</tr>
<tr>
</tbody>
</table>

This information helps you form a more thorough picture of Geeglo's instance and
narrow down the questions you need to ask to help troubleshoot. They can also
help you find solutions more quickly as you search through your support knowledge
base.
</file>

<file path="closing-information-gap/02-working-with-support-bundles/assignment.md">
---
slug: working-with-support-bundles
id: tydgy4bvf33n
type: challenge
title: Working with Support Bundles
teaser: |-
  Learn how support bundles help you understand what is going
  on with a customer instance
notes:
- type: text
  contents: Let's learn about Support Bundles
tabs:
- id: i3e2bpng3asx
  title: Shell
  type: terminal
  hostname: shell
- id: lbfyllzhfkz6
  title: Manifest Editor
  type: code
  hostname: shell
  path: /home
difficulty: basic
timelimit: 420
---

Instance Insights is a powerful tool to help you understand information you
need to know to assist a customer. It's the first tool you should pick up to
get context for the issue and can lead you toward the right troubleshooting
path. It was built to provide a set of insights for any application distributed
with the Replicated Platform. This limits it to information that's common
across applications.

Support bundles are another critical tool for troubleshooting customer issues.
The Replicated Platform allows you to define a bundle that your customer can
send to give you even more visibility into their environment. Since you define
the support bundle, it can collect details that are specific to troubleshooting
your application. Support bundles can also surface specific issues and provide
guidance to your customer in order to resolve issues on their own. They are part
of the [Troubleshoot](https://troubleshoot.sh) open source project.

What is a Support Bundle?
=========================

Support Bundles collect the information you need to understand your customer's
cluster and how your application is running in it. The Replicated Platform
allows you to do this without installing anything else into the cluster.

You define your bundle in a YAML file that follows the same format as a
Kubernetes object. The simplest support bundle object looks like this, and it's
in the file `simplest-support-bundle.yaml`:

```
apiVersion: troubleshoot.sh/v1beta2
kind: SupportBundle
metadata:
  name: simplest-support-bundle
spec:
  collectors: []
  analyzers: []
```

You can view the file in the Manifest Editor tab or from the command line.
Let's try collecting a support bundle with it.

```
kubectl support-bundle ./simplest-support-bundle.yaml
```

Since we haven't given it anything to collect or to analyze, it will error out
with a messsage similar to the one below.

```
Error: failed to run collect and analyze process: failed to generate support bundle
```

If you try this in your own environment, you may get a default support bundle created.
Earlier versions of the `support-bundle` plugin would generate a support bundle
with default collectors in this scenario.

Analyzers and Collectors
========================

Your support bundle both collects information about the cluster and analyzes it
to provide more insight into its state. If you have completed the [Avoiding
Installation
Pitfalls](https://play.instruqt.com/replicated/tracks/avoiding-installation-pitfalls)
lab these concepts will be familiar to you as the two types of objects that
make up preflight checks. Support bundles are also made up of _collectors_ that
collect data and _analyzers_ that analyze it.

There two default collectors included in every support bundle unless you
explicitly exclude or limit them. The `clusterInfo` collector collects
information about the running cluster, and the `clusterResources` collector
collects information about many of the resources running in the cluster. These
give you some baseline support information, but you will generally want to add
more collectors to gather logs and other details about your application state.

Log collection is the first thing most teams add to their support bundle. Let's
add some logging collectors so that our support bundle will collect logs
from the Slackernews application.

```
- logs:
    selector:
      - app=slackernews
```

This definition specifies that the logs from any workload where the label `app`
has the value `slackernews`. The Slackernews Helm chart we're using
for this lab applies that label to pods created for the application iteself.

The first analyzers teams add are generally those that identify if different
workloads are running (i.e. in a `Ready` state). Slackernews has a couple of
supporting services in additon to the app. Let's just take the app for this
first step.

```
- deploymentStatus:
    name: slackernews
    outcomes:
      - fail:
          when: "absent"
          message: |
            The Slackernews core component has not been deployed to this cluster. Please be sure to install the Slackernews
            application using its Helm chart.
      - fail:
          when: "< 1"
          message: |
            The Slackernews application is not currently running on this cluster. Please review the logs in this support
            bundle to locate any errors.
      - pass:
          message: |
            Ther Slackernews application is running on this cluster and ready for use.
```

Taken together, your support bundle definition will look like this:

```
apiVersion: troubleshoot.sh/v1beta2
kind: SupportBundle
metadata:
  name: slackernews-support-bundle
spec:
  collectors:
    - logs:
        name: /app/slackernews/logs
        selector:
          - app=slackernews
  analyzers:
    - deploymentStatus:
        name: slackernews
        namespace: slackernews
        outcomes:
          - fail:
              when: "absent"
              message: |
                The Slackernews core component has not been deployed to this cluster. Please be sure to install the Slackernews
                application using its Helm chart.
          - fail:
              when: "< 1"
              message: |
                The Slackernews application is not currently running on this cluster. Please review the logs in this support
                bundle to locate any errors.
          - pass:
              message: |
                Ther Slackernews application is running on this cluster and ready for use.
```

Getting Started
===============

Let's create a support bundle using this definition. Click on the "Manifest
Editor" tab and create a new file named `slackernews-support-bundle.yaml` in the
`/home/replicant` directory.

![Creating the Support Bundle File](../assets/creating-slackernews-support-bundle.png)

Paste the YAML above into the new file. The editor will automatically save it.

![Saving the Support Bundle File](../assets/saving-slackernews-support-bundle.png)

Now collect a support bundle using this definition.

```
kubectl support-bundle ./slackernews-support-bundle.yaml
```

You'll see that that your bundle has been collected and get a screen showing
the result for the analyzer you added.

![Slackernews isn't Running](../assets/failing-slackernews-status.png)

Notice that the support bundle has told use something that's wrong with the
installation.
</file>

<file path="closing-information-gap/03-additional-information/assignment.md">
---
slug: additional-information
id: lorzhundumdj
type: challenge
title: Collecting and Analyzing Additional Information
teaser: |
  Expanding the support bundle definition to collect and analyze
  more details about the application
notes:
- type: text
  contents: |
    Gather and analyze additional information to get a more completed picture
tabs:
- id: cnpgj5jxyaew
  title: Shell
  type: terminal
  hostname: shell
- id: vleuag7nhqbp
  title: Manifest Editor
  type: code
  hostname: shell
  path: /home/replicant
difficulty: basic
timelimit: 600
---

You have a useful support bundle right now. You can collect the logs
from the Slackernews app and you're able to verify if its core service is
running. This can be very useful information to help your team resolve support
cases more quickly with minimal back-and-forth with your customer.

Let's expand the support bundle to collect more information and provide
additional insight into the running application.

Expanding Log Collection
========================


The Slackernews application uses different labels to identify different
components that it installs. We want to make sure we get the logs from all the
components, including the Replicated SDK. To do this, we need to add additional
log collectors.

```
    - logs:
        name: /app/slackernews/logs
        selectors:
          - app=slackernews-nginx
    - logs:
        name: /app/slackernews/logs
        selectors:
          - app=postgres
    - logs:
        name: /app/slackernews/logs
        selectors:
          - app.kubernetes.io/name=replicated
```

Use the editor at the "Manifest Editor" tab to add these collectors to you
support bundle definition after the `logs` collector from the previous step.

![Adding Log Collectors](../assets/adding-log-collectors.png)


Collecting Application Configuration
====================================

The default support bundle collectors give you some useful details about the
Kubernetes cluster and many common resource types. Two types it does not
automatically collect are Secrets and ConfigMaps. These may contain valuable
troubleshooting clues, so you can specify collectors to include them.

You don't want to collect too much information when adding Secrets and
ConfigMaps to your support bundle. The support bundle collection process
redacts many sensitive values, but application configurations are likely to
contain more sensitive details than logs or other data you might collect. This
is especially true of values stored in secrets.

We're going to define collectors for some ConfigMaps and Secrets that are
critical to operating the Slackernews g. ConfigMaps are collected with the
`configMap` collector and Secrets with the `secret` collector. Both of these
give you different ways to control what to look for and what's collected. You
can choose to collect only specific resources or to collect them based on a
selector. You also have fine-grained control over which keys to look for and
whether to include the value at that key. Only include the value when
absolutely necessary and when it is likely to be known to you already.
## Collecting ConfigMaps

For our `configMap` collectors, we're going to collect the ConfigMap installed
by the application. We're going to include the value of the `default.conf` key
since it contains the NGINX configuration which shows what endpoint the server
is listening on. This will help us assure the application is listening where
the user expects to find it.

```
    - configMap:
        name: slackernews-nginx
        namespace: slackernews
        key: default.conf
        includeValue: true
```

Use the editor to add this collector to you support bundle definition after the
`logs` collector from the previous step.

![Adding ConfigMap Collectors](../assets/adding-configmap-collectors.png)

## Secret Collectors

There are several secrets that are critical to Slackernews running successfully. We
can use collectors to gather the information we need to know if the necessary secrets
are present, and in some case their values. We start with a few secrets that
its safe to know the value of, like TLS certificates which are essentially
public.

After that, we assure that required values are present for all of the other
secrets that are needed to run the application.

```
    - secret:
        name: slackernews-nginx
        namespace: slackernews
        key: tls.crt
        includeValue: true
    - secret:
        name: slackernews-nginx
        key: tls.key
        includeVale: true
    - secret:
        name: slackernews-postgres
        namespace: slackernews
        key: password
    - secret:
        name: slackernews-postgres
        namespace: slackernews
        key: uri
    - secret:
        name: slackernews-slack
        namespace: slackernews
        key: clientId
    - secret:
        name: slackernews-slack
        namespace: slackernews
        key: clientSecret
    - secret:
        name: slackernews-slack
        namespace: slackernews
        key: botToken
    - secret:
        name: slackernews-slack
        namespace: slackernews
        key: userToken
```

Use the editor to add these after the `configMap` collectors in your support
bundle specification file.

![Adding ConfigMap Collectors](../assets/adding-secret-collectors.png)

Analyzing Workloads
===================

In your initial support bundle definition you added a `deploymentStatus`
analyzer that checked whether the Slackernews Core workload was running. Core is one
of several workloads in the application. Some are Deployments, while others are
Stateful Sets. There is a `statefulSetStatus` analyzer that works the same way
for those resources.

To get a quick glimpse as to whether all the workloads that make up the Slackernews
g application are healthy, let's add `deploymentStatus` and
`statefulSetStatus` analyzers as required.

Since Slackernews is made up of an application and a couple of supporing
services, we're going to add the deployment and stateful set analyzers
separately.

```
    - deploymentStatus:
        name: slackernews-nginx
        namespace: slackernews
        outcomes:
          - fail:
              when: "absent"
              message: |
                The Slackernews web server has not been deployed to this cluster. Please sure to install the Slackernews g application using its Helm chart.
          - fail:
              when: "< 1"
              message: |
                The Slackernews web server is not currently running on this cluster. Please review the logs in this support bundle to locate any errors.
          - pass:
              message: |
                Ther Slackernews web server is running on this cluster and ready for use.
```

Use the editor in the "Manifest Editor" tab to add those to
`slackernews-support-bundle.yaml` after the Slackernews core analyzer you added in the
previous step.

![Adding Deployment Status Analyzers](../assets/adding-deployment-analyzers.png)

We'll do the same for the stateful set that provides the database for Slackernews.

```
    - statefulsetStatus:
        name: postgres
        namespace: slackernews
        outcomes:
          - fail:
              when: "absent"
              message: |
                The Slackernews database has not been deployed to this cluster. Please sure to install the Slackernews application using its Helm chart.
          - fail:
              when: "< 1"
              message: |
                The Slackernews database is not currently running on this cluster. Please review the logs in this support bundle to locate any errors.
          - pass:
              message: |
                Ther Slackernews database is running on this cluster and ready for use.
```

![Adding StatefulSet Status Analyzers](../assets/adding-statefulset-analyzers.png)

One Last Step
=============

Let's add the analyzers that are part of the Slackernews preflight checks to the
support bundle, just to make sure nothing troublesome has changed about the
cluster that could cause trouble for the instance. If you didn't complete the
[Avoiding Installation
Pitfalls](https://play.instruqt.com/replicated/tracks/avoiding-installation-pitfalls)
lab you may not have seen these before. They test to make sure the Kubernetes
version, CPU, and memory of the cluster will support running the Slackernews
g.

```
    - clusterVersion:
        outcomes:
          - fail:
              when: "<= 1.26.x"
              message: |-
                Your Kubernets cluster is running a version of Kubernetes that is no longer supported by the Kubernetes
                community and unable to be supported by Slackernews. Changes in Kubernetse since your current version mean
                that you installation will likely not succeed. Please upgrade your cluster or install to a different
                cluster running at least Kubernetes 1.26, ideally version 1.28.0 or later.

                If you are receiving extended support from your Kubernetes provider you may be able to ignore
                this warning. If not, we recomend that you upgrade your cluster to at least version 1.28.0.

              uri: https://kubernetes.io
          - warn:
              when: "< 1.27.0"
              message: |-
                Your Kubernetes cluster is running a version of Kubernetes that will go out of support active support in
                less than six months. We recommend that you upgrade your Kubernetes cluster to assure continued success with
                your Slackernews implementation.
              uri: https://kubernetes.io
          - pass:
              message: Your cluster is running a version of Kubernetes that is supported by Slackernews.
    - nodeResources:
        checkName: Cluster CPU resources are sufficient to install and run Slackernews
        outcomes:
          - fail:
              when: "sum(cpuAllocatable) < 2"
              message: |-
                Slackernews requires a minimum of 2 CPU cores in order to run, and runs best with
                at least 4 cores. Your current cluster has less than 2 CPU cores available to Kubernetes
                workloads. Please increase cluster capacity or install into a different cluster.
          - warn:
              when: "sum(cpuAllocatable) < 4"
              message: |-
                Slackernews runs best with a minimum of 4 CPU cores. Your current cluster has less
                than 4 CPU cores available to run workloads. For the best experience, consider
                increasing cluster capacity or installing into a different cluster.
          - pass:
              message: Your cluster has sufficient CPU resources available to run Slackernews
    - nodeResources:
        checkName: Cluster memory is sufficient to install and run Slackernews
        outcomes:
          - fail:
              when: "sum(memoryAllocatable) < 4G"
              message: |-
                Slackernews requires a minimum of 4 GB of memory in order to run, and runs best with
                at least 8 GB. Your current cluster has less than 4 GB available to Kubernetes
                workloads. Please increase cluster capacity or install into a different cluster.
          - warn:
              when: "sum(memoryAllocatable) < 8Gi"
              message: |-
                Slackernews runs best with a minimum of 8 GB of memory. Your current cluster has less
                than 8 GB of memory available to run workloads. For the best experience, consider
                increasing cluster capacity or installing into a different cluster.
          - pass:
              message: Your cluster has sufficient memory available to run Slackernews
```

You may want to add these as your first analyzers, since they call attention
to items that might prevent workloads from running and might explain other
failed analyzers.

![Adding Cluster Analyzers](../assets/adding-cluster-analyzers.png)

Generate the More Complete Support Bundle
==========================================

Now that you've enhanced your support bundle with more information about the
running application, let's generate another bundle and take a look at the
analyzers.

```
kubectl support-bundle ./slackernews-support-bundle.yaml
```

You'll see that that your bundle has been collected and get a
text interface showing the results of the analyzers you added.

![Complete Support Bundle Analysis](../assets/complete-support-bundle-analysis.png)

Press `q` to leave the support bundle analyzers interface.
</file>

<file path="closing-information-gap/04-adding-to-the-chart/assignment.md">
---
slug: adding-to-the-chart
id: wimuy9m224ls
type: challenge
title: Adding the Support Bundle to the Slackernews Helm Chart
teaser: Learn how to incorporate your support bundle into your chart
notes:
- type: text
  contents: Time to add your support bundle definition to the Slackernews Helm chart
tabs:
- id: gvcfeq0xolb5
  title: Shell
  type: terminal
  hostname: shell
- id: xs2tflck3nhu
  title: Manifest Editor
  type: code
  hostname: shell
  path: /home/replicant
difficulty: basic
timelimit: 600
---

You've put together a pretty robust support bundle definition for the Slackernews
registry. Now it's time to distribute that definition to your customers so that
they can collect a support bundle when you need it.

Making the Support Bundle Available
===================================

The Support Bundle specification looks a lot like a Kubernetes custom resource,
but strictly speaking it isn't. Instead it runs outside of the cluster and is
interpreted by the `support-bundle` plugin to the `kubectl` command.

Even if it isn't a Kubernetes resource, we still want to distribute the support
bundle specification as part of the application Helm chart. This saves you from
having to find a different distribution mechanism. It also makes it easier for
your customer to gather a support bundle for you.

To include the support bundle definition with your application, you're going to
store it in a Kubernetes secret. There are a couple of constraints on this
secret:

1. It has to have a label `troubleshoot.sh/kind: support-bundle`
2. You need to use the key `support-bundle-spec` for your support bundle
   specification.

If we consider the baseline support bundle from the first step in the lab, it
becomes a secret that looks like this


```
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: simplest-support-bundle
  labels:
    troubleshoot.sh/kind: support-bundle
stringData:
  support-bundle-spec: |-
    apiVersion: troubleshoot.sh/v1beta2
    kind: SupportBundle
    metadata:
      name: simplest-support-bundle
    spec:
      collectors: []
      analyzers: []
```

Let's add this secret to our cluster and execute it.

```
kubectl create -f simplest-support-bundle-secret.yaml
kubectl support-bundle --load-cluster-specs
```

_Note: The support bundle definition can also be stored as a `ConfigMap` with
the same annotation._


Adding Your Definition to the Slackernews Helm Chart
===============================================

Knowing that you should create a secret for your support bundle sets you up to
include it into the Slackernews Helm chart. There's some boilerplate required to
define that secret consistently with the naming, annotation, and labeling
conventions used in the chart. Bitnami, who provided the chart we're working
with, has a set of these. Your team likely has some as well.

Open the manifest editor and create a new file named `support-bundle.yaml` in
the directory `slackernews/templates/troubleshoot`. This will be the template that creates the
support bundle specification secret when the Helm chart is installed.

![Creating the Support Bundle Template](../assets/creating-the-support-bundle-template.png)

After creating the file, you may have to click on the filename to make sure it
is opened. Add the following to the file. This handles the metadata conventions
mentioned above and also add the label that specifies this is a support bundle
definition.

```
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "slackernews.name" . }}-support-bundle
  namespace: {{ .Release.Namespace | quote }}
  labels: {{- include "slackernews.labels" . | nindent 4 }}
    app.kubernetes.io/component: troubleshoot
    troubleshoot.sh/kind: support-bundle
type: Opaque
stringData:
  support-bundle-spec: |
```

Remember that the support bundle must be at a key named `support-bundle-spec`
to be found when generating a support bundle. Open the file
`slackernews-support-bundle.yaml` and copy/paste its content into the secret
template. Make sure the indentation is correct. Note that you can select the
content you just pasted in and tab twice in order to indent to the right place.

![Saving the Support Bundle Template](../assets/saving-the-support-bundle-template.png)

Repackaging Your Chart
======================

To distribute your support bundle, you should bump the version number in
`slackernews/Chart.yaml` (from `0.3.0` to `0.4.0`) adn then repackage it. You can edit
the version in the Manifest Editor or run the following command to do it from
the shell.

```
yq -i '.version = "0.4.0"' slackernews/Chart.yaml
```

and run the `helm package` command to package the updated version

```
helm package slackernews --destination ./release
```
</file>

<file path="closing-information-gap/05-releasing-an-update/assignment.md">
---
slug: releasing-an-update
id: ywybr4uyhntr
type: challenge
title: Releasing an Update with the Support Bundle
teaser: Releasing a new version with the support bundle included
notes:
- type: text
  contents: Let's create a release to distribute the support bundle
tabs:
- id: idcf1k25yddg
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 300
---

To make the support bundle available to the customer, we need to distribute it
to them. Since the Replicated Platform handles distribution for us, we need to
let the platform know a new release is available. This process will be familiar
to you if you have completed the [Distributing Your Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-your-application-with-replicated)
lab. You'll learn all you need to know to relasze your update here, but that
lab can help you to get a more complete picture if you'd like one.

Preparing to Release
====================

You'll need to be authenticated to the Replicated Platform to release your
update. The simplest way to do that is with the API token the lab setup create
for you. The `replicated` CLI will read that from an environment variable, so
let's set it.


```
export REPLICATED_API_TOKEN="[[ Instruqt-Var key="REPLICATED_API_TOKEN" hostname="shell" ]]"
```

The `replicated` command also needs to know which application to work with. You
can set it with a command flag or with an environment variable. Let's set the
variable to save some typing.

```
export REPLICATED_APP="[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]"
```

Creating an Upgraded Release
============================

There will be three releases already available for the Slackernews application. This
shows the eovlution of the application over time.

```
replicated release ls
```

All releases are assigned a sequence number based on the order in which they
are created. They may also be assigned to zero or more release channels that
provide specific streams of releases to specific customers. You'll see that the
the same release is current across all three channels, and it has the sequence
number `2`

```
SEQUENCE    CREATED                 EDITED                  ACTIVE_CHANNELS
2           2023-06-20T14:52:16Z    0001-01-01T00:00:00Z    Stable,Beta,Unstable
1           2023-06-20T14:50:52Z    0001-01-01T00:00:00Z
```

To release our update, we're going to create a new release including our
changes and assign it to the release channel `Unstable`, which is one of the
default release channels that is generally used internally for releases that
may or not be ready for customers.

```
replicated release create --promote Unstable --chart ./release/slackernews-0.4.0.tgz --version 0.4.0  \
  --release-notes "Adds a support bundle spec to facilitate troubleshooting"
```

This creates a release for version `0.4.0` of the Slackernews Helm chart, and
promotes it to the `Unstable` channel. The `create` command output sequence
number that you'll need for `promote` (it will be `3` if you haven't explored
releasing a bit more).

```
  _ Reading manifests from ./release _
  _ Creating Release _
    _ SEQUENCE: 3
  _ Promoting _
    _ Channel 2Qa7rGeBiT3DaDK85s6FVKRC7Mn successfully set to release 4
```


A Note About Release Channels
================================

The previous section mentioned release channels a few times. The [Distributing
Your Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-your-application-with-replicated)
lab goes into detail about release channels but it's worth explaining them a
pbit more here in case you haven't had a chance to go through that lab yet.
Release channels on the Replicated Platform allow you to provide difference
streams or release to different types of customers to make sure you get the
right releaes to each one. Each customer license is assigned to a channel, and
you assign each of your release to one or more channels.

By default, Replicated creates three release channels for each application:
`Unstable`, `Beta`, and `Stable`. You can probably guess from the names what
types of releases each one is intended for. You will likely also add your own
release channels to model how you distribute your software. Replicated
recommends, for example, that teams that use feature branches and/or a pull
request workflow create release channels for each branch. This allow teams to
create and distribuite releases from the branch for testing and validation.
Other team  creates release for customers who want either more or less frequent
releases that the standard release cadence.

Promoting the Release
=====================

For the lab, we're going to assume this release can be directly shared on the
`Beta` and `Stable` channels. You'll no doubt have a much more thorough process
to determine whether a release should be promoted to each of those
channels---hopefully automated as part of your continuous delivery pipelines.

```
replicated release promote 3 Beta --version 0.4.0 \
  --release-notes "Adds a support bundle spec to facilitate troubleshooting"
```

and then

```
replicated release promote 3 Stable --version 0.4.0 \
  --release-notes "Adds a support bundle spec to facilitate troubleshooting"
```

List your releases again to see that the release has been promoted.

```
replicated release ls
```

Your list of releases will now show four releases with the most recent release
available on the `Unstable`, `Beta`, and `Unstable` channels.

```
SEQUENCE    CREATED                 EDITED                  ACTIVE_CHANNELS
3           2023-06-20T14:55:32Z    0001-01-01T00:00:00Z    Stable,Beta,Unstable
2           2023-06-20T14:52:08Z    0001-01-01T00:00:00Z
1           2023-06-20T14:50:52Z    0001-01-01T00:00:00Z
```
</file>

<file path="closing-information-gap/06-support-bundle-diagnosis/assignment.md">
---
slug: support-bundle-diagnosis
id: rodjcnqzhonq
type: challenge
title: Using the Support Bundle to Diagnose the Issue
teaser: Discover the cause of Geeglo's outage using a support bundle
notes:
- type: text
  contents: Troubleshooting the unavailable instance using the support bundle
tabs:
- id: 3empyvcmm8td
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 420
---

Now that your application contains a support bundle definition, your support
team can request a support bundle from your customer to help troubleshoot their
issue. Since we've just released the verison containing the support bundle,
your customer will need to upgrade their instance first. Note that we're going
to go back and forth between the customer perspective and your perspective
during this step.

Upgrading the Instance
======================

We're going to start the lab from the perspective of our customer Geeglo. In
order to upgrade the application they need to log into the Replicated registry.
They will already have their credentials since this is not the first install.
If you need to provide them to them again, you can get them from the Replicated
Vendor portal.

```
helm registry login registry.replicated.com \
  --username [[ Instruqt-Var key="CUSTOMER_EMAIL" hostname="shell" ]] \
  --password [[ Instruqt-Var key="REGISTRY_PASSWORD" hostname="shell" ]]
```

Once they've logged in, they can run the `helm upgrade` command to upgrade
their instance.

```
helm upgrade slackernews --namespace slackernews \
  oci://registry.replicated.com/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews
```

Check to see if the support bundle secret has been created.

```
kubectl get secret --namespace slackernews
```

You should see the secret `slackernews-support-bundle` in the list of secrets. This
mean the support bundle is now available in the cluster.

```
NAME                           TYPE                 DATA   AGE
slackernews-postgres                Opaque                           2      27m
slackernews-slack                   Opaque                           4      27m
slackernews-nginx                   kubernetes.io/tls                2      27m
replicated-supportbundle            Opaque                           1      27m
replicated-pull-secret              kubernetes.io/dockerconfigjson   1      27m
replicated                          Opaque                           1      27m
slackernews-preflight               Opaque                           1      27m
slackernews-support-bundle          Opaque                           1      61s
sh.helm.release.v1.slackernews.v1   helm.sh/release.v1               1      27m
sh.helm.release.v1.slackernews.v2   helm.sh/release.v1               1      61s
```

There is also a `replicated-support-bundle` secret for the Replicated SDK. We
included specific items related to the Replicated SDK in our support bundle
definition, but we didn't have to since Replicated has offered it's own. All
available support bundles definitions are composed into one when we collect a
support bundle based on definitons available in the cluster.

Collecting a Support Bundle Using In-Cluster Specifications
===========================================================

Let's continue on as Geeglo and collect a support bundle using the in-cluster
specification you've provided to them. For this lab, we're going to assume they
already have the support bundle plugin installed. Instead of specifying a
support bundle file, they use the flag `load-cluster-specs` to load the support
bundle specifications from the `slackernews` namespace. We'll also specify the
filename for the bundle. You may want to ask your customers to specify a
filename including their company name to make it easier to keep track of the
bundles you are working with.

```
kubectl support-bundle --namespace slackernews --load-cluster-specs --output geeglo-support-bundle.tar.gz
```

This will show the analyzer results screen you saw when running the support bundle in your environment.

![Identifying the Failed Component from the Analyzer Output](../assets/identifying-the-failed-component.png)

You'll notice there's one different from when you tested the support bundle.
One of the analyzers is showing a failure, since the job service component is
not running in the customer cluster. This may be enough for the Geegle team to
start troubleshooting on their own and resolve the issue, or it may require
them to send the support bundle along to your support team for additional
diagnosis.

Troubleshooting with the Support Bundle
=======================================

Let's shift back to your perspective and assume that the Geeglo team has sent
you the support bundle. There are a few different ways for you to interact with
a support bundle:

* Opening up the tarball and digging through the files
* Uploading the support bundle to the Replicated Vendor Portal for a GUI showing analyzer results and allow you to navigate the file structure.
* Using a combination of `kubectl support-bundle` and the `sbctl` command to investigate the bundle contents.

We're going to use the third approach since it provides a familiar experience
to engineers who work with Kubernetes. Members of your support team who are
less comfortable on the command-line or with Kubernetes may opt to use the
Vendor Portal. Digging into the tarball is useful once you're familiar with the
support bundle structure and want to take a quick look.

### Analyzing the Support Bundle

The first thing we'll do is check the analyzers in the bundle we just received
from the vendor using the `support-bundle` command. Note that we have to
reference both the bundle and it's definition in order to see the analyzer
results.

```
kubectl support-bundle analyze --bundle geeglo-support-bundle.tar.gz ./slackernews-support-bundle.yaml | less
```

This command will output a YAML file showing results of all of the analyzers.
Look through the output to see which analyzers have an `isfail` or `iswarn`
value of `true` to see if it helps you isolate the issue. You'll notice the
same failure that you saw when you were pretending to be Geeglo.

```
- ispass: false
  isfail: true
  iswarn: false
  strict: false
  title: slackernews Status
  message: |
    The Slackernews application is not currently running on this cluster. Please review the logs in this support
    bundle to locate any errors.
  uri: ""
  iconkey: kubernetes_deployment_status
  iconuri: https://troubleshoot.sh/images/analyzer-icons/deployment-status.svg?w=17&h=17
  involvedobject: null
```

### Exploring the Support Bundle with `sbctl`

The command `sbctl` is another command provided by Replicated that starts a
server that uses the internal structure of the support bundle file to respond
to requests made to the Kubernetes API. This means you can use the same
`kubectl` commands you would use to troubleshoot the customer cluster with the
support bundle that you would use if your were connected to it.

You can start the `sbctl` with either the `server` subcommand, that starts the
server in the background, or with the `shell` command that starts the server
along with a shell that is configured for `kubectl` to connect to it by
default. Let's use the `shell` version here.

```
sbctl shell --support-bundle-location ./geeglo-support-bundle.tar.gz
```

The server will start and you'll be dropped into a new shell connected to it.

```
API server logs will be written to /tmp/sbctl-server-logs-289614664
Starting new shell with KUBECONFIG. Press Ctl-D when done to end the shell and the sbctl server
local-kubeconfig-2237268620
replicated@shell:~$
```

Since you know the issue is with the frontend deployment, you can start your
troubleshooting there. Let's `describe` it to see if we can discover why it
might not be running.

```
kubectl describe deployment -n slackernews slackernews | less
```

You'll can confirm that is wasn't running when the bundle was collected by
looking at the number of replicas, then scroll through to see if anything more
interesting jumps out.

```
Replicas:               1 desired | 0 updated | 0 total | 0 available | 0 unavailable
```

At the end of the output, you'll one of the conditions might jump out at you.

```
Conditions:
  Type          Status   Reason
  ----          ------   ------
  Available     False    MinimumReplicasUnavailable
  Progressing   Unknown  DeploymentPaused
```

It seems that someone at Geeglo paused the rollout of the Slackernews frontend
deployment. It's possible they also killed the running replica, or that it
failed in some other way and could not be replaced because of this condition.
You've likely found the cause of Geeglo's outage, and can work with them to
resume the paused deployment.

What if They Can't (or Won't) Upgrade?
======================================

Including a support bundle in your release is an important practice to make
sure the support bundle is available for their instance. In this example, we've
just made the support bundle is available for the first time while our customer
Geeglo is having an issue. This means they have to upgrade in order to collect
a support bundle. That might not always be desirable, or even possible. The
next step in this lab will explore what you can do in these scenarios.
</file>

<file path="closing-information-gap/07-other-ways/assignment.md">
---
slug: other-ways
id: 8acmsy6ralcy
type: challenge
title: Other Ways to Offer a Support Bundle
teaser: Explore other ways to distibute your support bundle and keep it up to date
notes:
- type: text
  contents: How else can you distribute your support bundle
tabs:
- id: t7gxs2jowsje
  title: Shell
  type: terminal
  hostname: shell
- id: e1zxlzigexon
  title: Manifest Editor
  type: code
  hostname: shell
  path: /home/replicant
difficulty: basic
timelimit: 600
---

The support bundle command just needs a specification to run, and it doesn't
matter how it locates it. It can load it from a local file, a URI, or (as we
did above) a secret in the cluster. You can provide the specification at a
publicly available URL to make it easy for them to collect a bundle with
changing their cluster.

Using a URI to Collect a Support Bundle
=======================================

The support bundle specification for this lab is publicly available on a
Google Cloud Storage bucket. To collect a support bundle using that spec, run
the following command:

```
kubectl support-bundle --namespace slackernews https://storage.googleapis.com/shared-lab-assets/closing-the-information-gap/slackernews/slackernews-support-bundle.yaml
```

You'll see the now familiar analyzer screen showing your customer's cluster.
Since they've now resolved the incident, it will the job service running. If
you look closely, you'll also notice an additional analyzer in this version of
the support bundle.

![Results from Running the Support Bundle from a URI](../assets/analyzers-from-the-uri.png)

You can also use this mechanism to release your support bundle independent of
your application. This can allow the support team to evolve the bundle
independent of your development team and without requiring a full system
release. If you choose to distribute your support bundle at it's own URI, you
should still include it in your application. The support bundle spec allows has
a `uri` property that will be checked before using the specification as is. If
the spec can be retrieved, it will replace the spec that references it.

Including the URI in the Bundle You Distribute
==============================================

Let's finish of our work with the Slackernews support bundle by adding a `uri` to
the spec. Edit the file `slackernews/templates/troubleshoot/support-bundle.yaml` in the
Manifest Editor and add the URI from the command at the top of the `spec`,
before the collectors.

```
  uri: https://storage.googleapis.com/shared-lab-assets/closing-the-information-gap/slackernews/support-bundle.yaml
```

Don't forget to the save the file.

![Adding a URI to the Support Bundle spec](../assets/adding-a-uri-to-the-spec.png)

You should also bump the version number for the release to `0.4.1` in the
`Chart.yaml` file, repackage your chart, and delete the old tarball from your
release directory. The following commands will take care of that for you.


```
yq -i '.version = "0.4.1"' slackernews/Chart.yaml
helm package slackernews --destination ./release
rm ./release/slackernews-0.4.0.tgz
```

Now you need to release your update and promote it. Remember that for a real
application you won't be instantly promoting to `Beta` and `Stable`. Your
release sequence will be `5` unless you've played around with additional
releases. If you have, use the current sequence.

```
replicated release create --promote Unstable --chart ./release/slackernews-0.4.1.tgz --version 0.4.1  \
  --release-notes "Provides the ability to upgrade the support bundle independent of the application"
replicated release promote 4 Beta --version 0.4.1 \
  --release-notes "Provides the ability to upgrade the support bundle independent of the application"
replicated release promote 4 Stable --version 0.4.1 \
  --release-notes "Provides the ability to upgrade the support bundle independent of the application"
```

Running the New Bundle as Geeglo
================================

You can now resume acting as Geeglo to upgrade your installation and collect a
new support bundle containing a reference to your independently released
bundle.

```
helm upgrade --namespace slackernews slackernews \
  oci://registry.replicated.com/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews
kubectl support-bundle --namespace slackernews --load-cluster-specs
```

Note that you didn't add a new analyzer to the support bundle defintion in your
Helm chart, but you still see the new analyzer in your results this is because
the `support-bundle` command checked the URI for an upgrade, found one, and
used in instead of the out-of-date specification.

![Additional Analzer Result After Spec is Updated](../assets/additional-analyzer-result.png)
</file>

<file path="delivering-as-an-appliance/01-specifying-the-cluster/assignment.md">
---
slug: specifying-the-cluster
id: fjuasdxyavzw
type: challenge
title: Starting Your Appliance Configuration
teaser: Enable and configure the embedded cluster
notes:
- type: text
  contents: Let's build a Kubernetes appliance
tabs:
- id: fuunbnxuyib8
  title: Release Editor
  type: code
  hostname: shell
  path: /home/replicant
- id: kdwtxtxjaaxc
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 300
---

A virtual Kubernetes appliance consists of your application, a Kubernetes
cluster, and a console that your customer uses to install your application and
manage the appliance. We refer to the installer that deploys your application,
the cluster, and the console as Embedded Cluster because it 'embeds'
Kubernetes with your application. The console to install and manage your
application is called the Admin Console. Under the hood, the Admin Console
uses Helm to install and upgrade your application.

You release your application as a Kubernetes applicance by releasing a Helm
chart and some additional configuration on the Replicated Platform. The most
important file is the configuration for the Embedded Cluster installer, which can be very
simple. All it requires is the version of the cluster to use.

```
apiVersion: embeddedcluster.replicated.com/v1beta1
kind: Config
spec:
  version: [[ Instruqt-Var key="EMBEDDED_CLUSTER_VERSION" hostname="shell" ]]
```

That specification lets the Replicated Vendor Portal know which version of
Kubernetes to embed. There are [more options for the
configuration](https://docs.replicated.com/reference/embedded-config), but
that's all you need to get started.

The Replicated Release
======================

The Replicated Platform distributes your software to your customers. To do
this, it needs to know about your application, its customers, and the files
you're shipping to them. We talk about those files as a release.

Every release is built around a Helm chart, and that's all it needs. If you've
completed the [Distributing Your Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-with-replicated)
lab, you built a release around a Helm chart and installed it using Helm
tools. To use other installation methods supported by the Replicated Platform
you supplement the Helm chart with additional configuration files. We need a
minimum of two configuration files: the Embedded Cluster configuration and a
file that describes which Helm chart to install.

Our Initial Appliance
=====================

To create our initial appliance, we're going to add our Helm chart and two
configuration files to the `release` directory. These are the bare minimum set
of files we need to create the appliance.

### Bumping the Chart Version

Strictly speaking, we don't have to bump the version of our Helm chart since
we haven't changed it. It's a good practice to increment it, though, since we
want to have consistent versions between the Helm release and the Replicated
release. That way your customer will see a consistent version regardless of
the install mechanism they choose.

This lab uses the application [SlackerNews](https://slackernews.io) and the
Helm sources for it are in the `slackernews` directory. Open
`slackernews/Chart.yaml` in the "Release Editor" tab and update the `version`
to `0.6.0`.

![Updating the version of the Helm chart to 0.6.0](../assets/updating-the-chart-version.png)

### Adding a Helm Chart to a Release

To prepare the release, we first need to make sure our Helm chart is configured
as part of it. From the Shell tab, package the chart and include it in the
`release` directory, where we'll also add the additional files we need.

```
helm package -u slackernews -d release
```

We're then going to add a file that lets the Admin Console know about the Helm
chart. It uses this file to identify which chart to install and pass the
appropriate values. We'll look at the passing values in a later section of the
lab when we set up the configuration screen for our application.

Go to the "Release Editor" tab to add a file named `slackernews-chart.yaml` to
the `release` directory.

![Creating a manifest file describing your Helm chart](../assets/creating-the-helmchart-object.png)

The editor may not open your new file automatically. If it doesn't, click on
it to open it. Add the following content to the file. Note that it looks like
a Kubernetes custom resource, but it's really not. Instead, it's processed by
the Admin Console to avoid the complexity of creating a CRD and the relevant
controllers. The name and version in this file need to match the metadata for
our SlackerNews Helm chart to identify it correctly.

```
apiVersion: kots.io/v1beta2
kind: HelmChart
metadata:
  name: slackernews
spec:
  # chart identifies a matching chart from a .tgz
  chart:
    name: slackernews
    chartVersion: 0.6.0

  # values are used in the customer environment, as a pre-render step
  # these values will be supplied to helm template
  values: {}
```

You're not limited to only one Helm chart as part of your application.
Including multiple `HelmChart` objects let's the Admin Console know it has to
install multiple Helm charts. For SlackerNews, we have only a single chart.

### Including the Embedded Cluster Installer

We showed a simple Embedded Cluster configuration earlier in the lab. Let's use
that basic configuration for SlackerNews. Create another file in the `release`
folder named `embedded-cluster.yaml` and copy the contents of the configuration
into it.

```
apiVersion: embeddedcluster.replicated.com/v1beta1
kind: Config
spec:
  version: [[ Instruqt-Var key="EMBEDDED_CLUSTER_VERSION" hostname="shell" ]]
```

Releasing the Appliance
========================

With the three files we have, we can now release SlackerNews Kubernetes
appliance. We're going to use the `replicated` command-line tool for to create
the release. The first thing we'll do is set some environment variables to let
the command know who we are and what application we're working with. Use the
"Shell" tab to set these variables:

```
export REPLICATED_API_TOKEN="[[ Instruqt-Var key="REPLICATED_API_TOKEN" hostname="shell" ]]"
export REPLICATED_APP="[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]"
```

We create a new release with the `release create` subcommand for `replicated`.
If you've completed some of our other labs you may notice a difference here:
we're using a flag `--yaml-dir` instead of `--chart`. That's because this
release requires the additional configuration files we've created.

```
replicated release create --yaml-dir ./release
```

This creates a release for version `0.6.0` of your SlackerNews appliance on
the vendor portal. To make it available to your customers, you need to publish
it to a release channel. Release channels are used by the Replicated Platform
to ensure customers get access to the release you intend for them to get. The
[Distributing Your Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-with-replicated)
lab explains release channels in more detail.

There are three default release channels: `Unstable` for internal builds,
`Beta` for your beta programs, and `Stable` for generally available releases.
We're going to use the `release promote` subcommand to make sure our release is
available on all three of them.

```
replicated release promote 7 Unstable --version 0.6.0 \
  --release-notes "Adds an embedded cluster configuration to facilitate an appliance experience"
```

followed by

```
replicated release promote 7 Beta --version 0.6.0 \
  --release-notes "Adds an embedded cluster configuration to facilitate an appliance experience"
```

and then

```
replicated release promote 7 Stable --version 0.6.0 \
  --release-notes "Adds an embedded cluster configuration to facilitate an appliance experience"
```

You can see the that your release is on all three channels by listing your
available channels by running

```
replicated channel ls
```

which will show the current release and version on each channel.

```
ID                             NAME        RELEASE    VERSION
2gWopn8RA2fQyMEXSoO0WdtwxX3    Stable      7          0.6.0
2gWopkEwUauoDmR2FaU4SMuL9wz    Beta        7          0.6.0
2gWopmvSXKiRRCDUXkAfP2p2Pcv    Unstable    7          0.6.0
2gWotHQsBB4bR5duhVhpQIAYWKs    LTS
```

You'll notice there's an additional channel that doesn't have your release on
it. That's an example of a release channel you could add when releasing your
own application. SlackerNews determined that some customere wanted "long-term
support" releases since they upgrade more slowly and wanted longer support
guarantees for the versions they installed.
</file>

<file path="delivering-as-an-appliance/02-customize-for-your-app/assignment.md">
---
slug: customize-for-your-app
id: 6003pttnmqok
type: challenge
title: Customizing the Appliance for Your Application
teaser: Make the Kubernetes appliance experience your own
notes:
- type: text
  contents: Customize the appliance Admin Console to represent your application
tabs:
- id: ybi0oubv14zx
  title: Release Editor
  type: code
  hostname: shell
  path: /home/replicant
- id: qgpmbdncfnse
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 300
---

The Kubernetes appliance installation is one of the first things
your customer will experience about your application. The way we've implemented
it so far uses a lot of defaults. We didn't try to install it yet, but if we
had, we'd land on a page like this:

![Appliance login page without branding](../assets/unbranded-admin-console.png)

This definitely violates our brand standards!

Don't worry, Replicated provides a few options to customize the appliance
Admin Console. The first customizations we're going to look at will make it clear
which application we're installing.

Adding a Name and Logo to the Appliance
=======================================

We've already looked at two of the resources we use for configuring the
appliance experience: one for the embedded Kubernetes cluster and one for the
SlackerNews Helm chart. There are others as well. We're going to look at the
`Application` resource, which describes the application being installed. There
are several things we can configure in this file as well, but for this lab
we'll focus on the title, icon, and how to determine application status. For
other possible properties, take a look at the [reference
documentation](https://docs.replicated.com/reference/custom-resource-application).
Not all of the possible values apply for the Kubernetes appliance experience.

The appliance installation process also supports another resource that
describes application metadata. The resource is defined by the
Kubernetes Apps Special Interest Group (SIG) and is also called `Application`.
This `Application` resource is not unique to the Replicated Platform. It's
also not required for the appliance installation experience.

We'll start with adding the Replicated `Application` resource for basic
branding, then we'll expand on it a bit. We're going to skip the SIG
`Application` for this lab.

### Add the Application Manifest

Let's go back to the "Release Editor" tab and add a new file for the
application metadata. Create a new file in the `release` directory named
`replicated-app.yaml`
it.

![Adding the application metadata manifest](../assets/adding-application-manifest.png)

Let's start with just the name and log for the application. This will make
sure that they're both available to the Admin Console for the appliance
installation experience.

```
apiVersion: kots.io/v1beta1
kind: Application
metadata:
  name: slackernews
spec:
  title: SlackerNews
  icon: "https://uploads-ssl.webflow.com/6310ad0e6a18aa1620da6ae8/6330e04f42bc6a7ba03b4725_snicon.png"
```

Enriching the Admin Console
===========================

To improve the SlackerNews appliance experience, we'll configure an
application status indicator. This will help an administrator understand the
running state of the application and quickly connect to it.

### Reporting Status on the Admin Console

Application status is reported based on status informers identified in the
Replicated `Application` resource. Status informers help the Admin Console
determine the application status to display. The status is an aggregation
across the provided status informers.

Application status is similar to the status you see for a Kubernetes
resource when using the `kubectl` command. The statuses provided are based on
the resources configured as status informers.

<table>
<thead>
</tr><th>Status</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Ready</td><td>All of the resources are ready</td></tr>
<tr><td>Unvailable</td><td>One or more of the resources are unavailable</td></tr>
<tr><td>Degraded</td><td>One or more of the resources are in a degraded state</td></tr>
<tr><td>Updating</td><td>There are multiple versions of the some resource present</td></tr>
<tr><td>Missing</td><td>The resources have not yet been created</td></tr>
</tbody>
</table>

Status informers can reference one of several types of resource:

* Deployments
* StatefulSets
* DaemonSets
* Services
* PersistentVolumeClaims
* Ingresses

Each status informer will be in one of the states above, as determined by the
resource it references. Missing is the same for all resources: it has not yet
been created.

<table>
<tbody>
<tr><td><code>Deployment</code><br/><code>StatefulSet</code></td><td>Status is based on the number
of replicas that are ready. A resources is ready if all replicas are
available, degraded one but not all replicas are ready, and unavailable if
none are ready. If there are replicas are from different versions then the
resources is updating.</td></tr>
<tr><td><code>DaemonSet</code></td><td>Similar to </code>Deployment</code> or </code>StatfulSet</code> but based on
the daemon pods</td></tr>
<tr><td><code>Service</code><br/><code>Ingress</code></td><td>Services are ready if all endpoints are ready and any
needed load balancers have been assigned. They are degraded if at least one
endpoint is ready when more are requests, and unavailable if none are ready
and no load balancer(s) have been assigned. Ingress is based on the same
criteria for it's backing service.</td></tr>
<tr><td><code>PersistentVolmeClaim</code></td><td>A PVC is ready if the claim is bound and
unavailable if it is either lost or pending. Those are the only two states.</td></tr>
</tbody>
<table>

SlackerNews has three components in it's architecture: the application, and
NGINX web server, and a Postgres database. It can optionally have an ingress
as well, but will not in the virtual appliance. Let's add status informers for
the application and the web server.


In the "Release Editor" tab, add the following to the `spec` section of the
manifest.

```
  statusInformers:
    - deployment/slacknerews
    - deployment/slackernews-nginx
```

![Adding the application metadata manifest](../assets/adding-status-informers.png)

We haven't provided a status informer for Postgres since the customer can
choose to bring their own database. We'll add it in when we work with the
customer configuration in the next step of this lab.

Releasing the Appliance
==========================

We're still not going to install our appliance, but let's release these
changes to get into the habit of releasing changes quickly.

First we want to bump the version in our Helm chart. You could consider this
part optional since we didn't update the chart. I recommend you do it, since
different customer may install the application in different ways. It will be
much easier for your team if Helm installs using version `0.6.1` and appliance
installs using version `0.6.1` are using the same bits.

You can bump the chart version in your editor, or just run the following two
commands

```
yq -i '.version = "0.6.1"' slackernews/Chart.yaml
yq -i '.spec.chart.chartVersion = "0.6.1"' release/slackernews-chart.yaml
```

You need to edit both files to ensure that the appliance refers to the current
chart. You also need to repackage your Helm chart and make sure your old
package isn't still in the release directory.

```
helm package -u slackernews -d release
rm release/slackernews-0.6.0.tgz
```

Create a new release, and promote it directly to the "Unstable" channel.

```
replicated release create --promote Unstable --yaml-dir ./release --version 0.6.1 \
  --release-notes "Configures appliance branding, status, and dashboard links" \
  --app ${REPLICATED_APP} --token ${REPLICATED_API_TOKEN}
```

We'll be making a few more changes before we install, so let's skip promoting
the release to the "Beta" and "Stable" channels.
</file>

<file path="delivering-as-an-appliance/03-collecting-configuration/assignment.md">
---
slug: collecting-configuration
id: cbk7exkrn99b
type: challenge
title: Collecting Application Configuration
teaser: |
  Help your users configuration your application with a custom
  configuration screen.
notes:
- type: text
  contents: |
    Help your users configure your application with a simple form
tabs:
- id: h7hyb0imphye
  title: Release Editor
  type: code
  hostname: shell
  path: /home/replicant
- id: tvyvcofb2ocv
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 300
---

One of the benefits of building a Kubernetes appliance is providing a guided
experience for your customer to have a successful installation. One key to
success is ensuring the application is correctly configured. Replicated
Embedded Cluster lets you offer a simple web screen to help customers set
critical values correctly.

Configuring Your Application
=============================

Like other aspects of the appliance, the configuration screen is defined using
a YAML manifest. The manifest defines a `Config` resource that describes your
configuration options and the screen that your customer will use to configure
the application. Configurations is organized into groups, and each group can
have a fields of different types. The type of field defines the widget used.
The supported types account for all of the standard web form inputs.

<table>
<thead>
<tr><th>Type</th><th>Widget</th></tr>
</thead>
<tbody>
<tr><td><code>bool</code></td><td>checkbox</td></tr>
<tr><td><code>file</code></td><td>file upload</td></tr>
<tr><td><code>heading</code></td><td>a subheading within a group</td></tr>
<tr><td><code>label</code></td><td>an label supporting another field</td></tr>
<tr><td><code>password</code></td><td>password field with obscured text and visibility
toggle</td></tr>
<tr><td><code>radio</code></td><td>radio buttons</td></tr>
<tr><td><code>dropdown</code></td><td>a dropdown menu</td></tr>
<tr><td><code>text</code></td><td>a standard text field</td></tr>
<tr><td><code>textarea</code></td><td>a larger text area</td></tr>
</tbody>
</table>

Each field has several other properties to specify things like its name,
default value, and whether it's required, among other things. The full list of
properties is in the [item
properties](https://replicated.zoom.us/my/crdant?pwd=NU5VVktueXV4QW0wcXFFRElHTkxudz09)
section of the Replicated documentation.

### Configuring SlackerNews

The SlackerNews Helm chart has several values that need to be set for it to
run as expected. Here's a first cut at the fields we want to collect: this
shows all of the values someone might want to enter to get a start with using
SlackerNews.

```yaml
apiVersion: kots.io/v1beta1
kind: Config
metadata:
  name: slackernews-config
spec:
  groups:
    - name: slackernews
      title: Application Core
      items:
        - name: slackernews_domain
          title: Ingress Hostname
        - name: slackernews_admin_user_emails
          title: Admin Users
          type: text

    - name: ingress
      title: Application Access
      items:
        - name: service_type
          title: Service Type
          type: radio
          items:
            - name: cluster_ip
              title: ClusterIP
            - name: node_port
              title: NodePort
            - name: load_balancer
              title: LoadBalancer
        - name: node_port_port
          title: Node Port
          type: text

    - name: tls
      title: Certificates
      items:
        - name: certificate_source
          type: radio
          title: Certificate Source
          items:
            - name: generate_internal
              title: Generate
            - name: upload_existing
              title: Upload
        - name: tls_cert
          title: Certificate
          type: file
        - name: tls_key
          title: Private Key
          type: file
        - name: tls_ca
          title: Signing Authority
          type: file

    - name: slack
      title: Slack Settings
      items:
        - name: slack_clientid
          title: Slack Client ID
          type: text
        - name: slack_clientsecret
          title: Slack Client Secret
          type: password
        - name: slack_user_token
          title: User OAuth Token
          type: password
        - name: slack_bot_token
          title: Bot User OAuth Token
          type: password

    - name: postgres
      title: Postgresql
      items:
        - name: deploy_postgres
          type: bool
          title: Deploy Postgresql Database
          default: "1"
        - name: postgres_password
          type: password
          title: Postgresql Password
        - name: postgres_external_uri
          type: text
          title: Postgresql URI
```

Let's add this configuration to the Replicated Platform release. Create a file
in the `release` directory named `config.yaml` and paste the content above into
it.

Improving the Configuration Experience
======================================

This configuration works, but has a few weaknesses:

1. It's not clear what all of the fields are for and how they interact.
2. Does the user need to fill out all the fields?
3. Some values might have defaults that are good enough for most users.
4. A few values have specific formats that the user might not enter correctly.

We can improve the experience by adding more detail to each configuration
field in a few ares: help text, default values, and validation. We can also
address the relationship between fields by hiding/showing fields based on the
value of other options.

### Adding Help Text

Help text is a simple way to provide more information about a field. It shows
above the widget to guide the user on what to enter.

![Help text for the Admin Users field](../assets/admin-users-help-text.png)

Each field can have help text, and you can add a description to each group of
configuration items to provide context across fields. This can be especially
helpful to explain how fields interact when you have dependencies between
them.

![Description of the "Application Access" configuration group](../assets/application-access-description.png)

We'll add help text to most of our fields, and also add descriptions to each
group. Let's start with the "Application Core" group. Update the `config.yaml`
by replacing the group named `slackernews`.

```yaml
   - name: slackernews
      title: Application Core
      description: |
        For this section, you can specify some core parameters for how
        SlackerNews operates, including the domain where users will access it
        and the user who can administer it.

        Users that you specify under **Admin Users** will be able to access the
        SlackerNews adminstrative console at `/admin`, allowing them to manage
        content, users, and settings. Changes will take effect the next time
        they are active in the SlackerNews application.
      items:
        - name: slackernews_domain
          title: Ingress Hostname
          help_text: >
            The domain name at which you'll access SlackerNews. Don't include
            the `https://` or any path elements.
          type: text
        - name: slackernews_admin_user_emails
          title: Admin Users
          type: text
          help_text: >
            Provide a comma-separated list of email addresses for the users you
            want to grant admin access to.
```

You can see we've used the `help_text` and `description` properties to provide
more instruction and support to the user installing the application. You'll
want to use these properties on most if not all of your configuration groups
and options. We're not going to go through the entire configuration right now,
but at the end of this section we'll take a look at a robust SlackerNews
configuration.

### Requiring Options and Providing Defaults

The goal of the configuration screen is to guide the user through successfully
deploying the appliance. The most important thing it can do is to distinguish
the options that a customer needs to change from other Helm values. It does
this through curating the values presented and explaining them to the user
running the install. The next most important thing it can do is make sure that
values that need to be configured get configured.

There are two ways to do this: specifying an option as required and providing
a default value. Let's continue to focus on the "Application Core" group. The
application can't run without knowing what hostname it's listening on, so
let's use the `required` property on the "Ingress Hostname" option.

```yaml
        - name: slackernews_domain
          title: Ingress Hostname
          help_text: >
            The domain name at which you'll access SlackerNews. Don't include
            the `https://` or any path elements.
          type: text
          required: true
```

Jump into the "Release Editor" and make that change. This will update how the
field is rendered and enforce that the user provides a value before they can
save their configuration.

![Required field for the Ingress Hostname](../assets/required-ingress-hostname.png)

There are no sensible default values for the options in the "SlackerNews Core"
group, so let's move on temporarily to the "Certificates" group. The
application will always run over TLS, but we can default to generating a
self-signed certificate.

```yaml
        - name: certificate_source
          type: radio
          title: Certificate Source
          default: generate_internal
          items:
            - name: generate_internal
              title: Generate
            - name: upload_existing
              title: Upload
```

Add those changes as well. We'll see a few default values in the final
configuration.

### Displaying Fields Conditionally

If we accept the default self-signed certificate option, we don't need to
upload the three files that support using our own. We could use the group
description to explain this. A better choice for our users, though, would be
to show those fields only if they're needed. We can do this by adding a
property called `when` to those fields, and using a bit of templating to
determine when the fields should be shown.

```yaml
        - name: tls_cert
          title: Certificate
          type: file
          when: '{{repl ConfigOptionEquals "certificate_source" "upload_existing"}}'
        - name: tls_key
          title: Private Key
          type: file
          when: '{{repl ConfigOptionEquals "certificate_source" "upload_existing"}}'
        - name: tls_ca
          title: Signing Authority
          type: file
          when: '{{repl ConfigOptionEquals "certificate_source" "upload_existing"}}'
```

The templating under `when` is based on Go templates. In this case, we're
looking at the value of the `certificate_source` option and only collecting
the files if the user wants to upload their own certificate. In the next
section of the lab we'll look at templating a bit more.

Make these changes to the three conditional fields in the "Certificates"
group. Like the other features we're looking at, you'll see a few more
conditional fields in the final configuration.

### Validating Input

The last feature we'll look at is input validation. Validation makes sure the
user sets a value in the correct format (unfortunately, we can't make sure
it's the _right_ value, the customer has to handle that). Fields validation
uses regular expressions.

Let's return the "Ingress Hostname" field. It's important for this field to be
a valid hostname. Though we can't check that it's a real domain here (that's
the type of thing preflight checks are for), we can make sure it's a valid
name.

```yaml
          validation:
            regex:
              pattern: ^(([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)\.)+([a-zA-Z]{2,6}|[a-zA-Z0-9-]{2,30}\.[a-zA-Z]{2,3})$
              message: Please enter a valid hostname

```

If your customer enters an invalid hostname they'll see the error message and
won't be able to save their configuration until they correct it. Edit the
config to include this validation by pasting it under the `required` property
of the "Ingress Hostname" field. Keep in mind that the validation is a regular
expression, so you'll want to test it to make sure it's correct. You can do
that when you install the appliance, which we'll do a bit later.

A More Robust Configuration
============================

All of the techniques we used to enrich our configuration can be applied to
any configuration option. In the case of SlackerNews, we have a few more
changes we could make:

* Explain the rest of the configuration groups and add help text to additional
  options
* Set sensible defaults where appropriate
* Hide other conditional fields
* Validate the input for fields with specific formats

We're not going to go through all of those changes step-by-step, but instead
we'll replace the configuration we've been working on with a more robust one.
The full configuration is located in your home directory in the file
`complete-configuration.yaml`. Please move or copy the contents of that file into your
configuration in place of the one we've been working on.

```
mv ~/complete-configuration.yaml ~/release/config.yaml
```


![A look at the complete SlackerNews configuration](../assets/complete-configuration.png)

In the next section we'll see how the Admin Console uses this configuration.
</file>

<file path="delivering-as-an-appliance/04-using-the-configuration/assignment.md">
---
slug: using-the-configuration
id: okm0gdijgbav
type: challenge
title: Using the Configuration to Install and Upgrade
teaser: Now we can customize the installation with the configuration
notes:
- type: text
  contents: |
    Provide the user configuration to your Helm chart
tabs:
- id: 1nfbe9hpgfhw
  title: Release Editor
  type: code
  hostname: shell
  path: /home/replicant
- id: v1glcc2whytp
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 300
---

The configuration screen we built looks great, guides the customer through
their configuration, and helps make sure they set their configuration is set
up correctly.

The next step is to configure the application using the options
they provide. Values from the configuration are mapped to the Helm chart(s)
that make up your application using the `HelmChart` resource. The Admin
Console uses this resource to prepare the values passed to Helm when
installing or upgrading the chart.

Passing Configurations to Helm
==============================

We saw the `HelmChart` resource when we initially prepared the cluster. In that
section we specified a chart and version to install and explicitly provided no
values to the Helm command (`values: {}`). We're going to fix that now and
provide values based on the configuration the Admin Console collected.

### A Word on Templating

[Templating in the Admin Console](https://docs.replicated.com/reference/template-functions-about)
is a big topic and an in-depth treatment would take it's own lab (or three).
We'll go over the basics that we need to use here, building on the
glimpse we had when setting up conditional fields on the configuration screen.

### Setting Helm Chart Values

We're going to elaborate our `HelmChart` manifest to include all the values
we collected from the user. Let's update the file `slackernews-chart.yaml`
incrementally to set all the values we've asked for.

The `HelmChart` object has two ways of supplying values during installations
and updates. The `values` key supplies values that are used for every
operation, while the `optionalValues` key allows you to conditionally set
values. The combined set of values will be passed to the Helm command when the
Admin Console installs or updates the application.

### Values

The `values` key is for values that will always be set the same way during an
install or upgrade operation. These values can be templated, so they can change
based on context like user configuration or license details. But they will
always be passed to the `helm` command and will always be set using the same
expression. The authentication information for SlackerNews is a good example.
It is always set using the four values the user provides.

```yaml
  values:
    slack:
      botToken: repl{{ ConfigOption "slack_bot_token" | quote }}
      userToken: repl{{ ConfigOption "slack_user_token" | quote }}
      clientId: repl{{ ConfigOption "slack_clientid" | quote }}
      clientSecret: repl{{ ConfigOption "slack_clientsecret" | quote }}
```

We're using template functions to pull in the configuration options. For
example, `repl{{ ConfigOption "slack_bot_token" | quote }}` will retrieve
the value of the `slack_bot_token` configuration option and wrap it in quotes.

### Optional Values

Optional values are used when you want to conditionally set values based on
some other context that the Admin Console can provide. Generally that context
comes from the user's configuration, but it could also come from the license
or the cluster. You can use as many conditions as you need for optional
values. Each condition is part of the `optionalValues` list, specified with a
`when` key.

You also specify how to merge the values from `optionalValues` and `values`
together using `recursiveMerge`. If `recurisveMerge` is false, then the
top-level key from the `optionalValues` clause overwrites the top-level key
from `values`.

In other words, if you have `recursiveMerge: false` (the default), then:

```
values:
  slack:
    botToken: repl{{ ConfigOption "slack_bot_token" | quote }}
    userToken: repl{{ ConfigOption "slack_user_token" | quote }}
optionalValues:
  - when: `{{repl eq (LicenseFieldValue "licenseType") "trial" }}
    values:
      slack:
        mock: true
```

then the result will be:

```
slack:
  mock: true
```

whereas if you have `recursiveMerge: true`, then the result will be

```
  slack:
    botToken: xoxb-pretendthisisyourbottoken
    userToken: xoxp-pretendthisisyourusertoken
    mock: true
```

For SlackerNews, we use optional values to determine how to configure the
database. Since there are some database configurations that are always set in
the same way, we specify a recursive merge.

```yaml
  optionalValues:
    - when: '{{repl ConfigOptionEquals "deploy_postgres" "1"}}'
      recursiveMerge: true
      values:
        postgres:
          password: '{{repl ConfigOption "postgres_password" }}'

    - when: '{{repl ConfigOptionEquals "deploy_postgres" "0"}}'
      recursiveMerge: true
      values:
        postgres:
          uri: '{{repl ConfigOption "postgres_external_uri" }}'
```

Specifying Image Values
=======================

If you completed the [Protecting Your
Assets](https://play.instruqt.com/manage/replicated/tracks/protecting-your-assets)
lab, you worked through the configuration for the Replicated Proxy Service to
secure access to your private images. When installing with Embedded Cluster, you
need to consider the proxy as well as the possibility of an airgap
installation. There are a few template functions to facilitate this. These
functions are part of the [config
context](https://docs.replicated.com/reference/template-functions-config-context)
within the Admin Console.

```yaml
    images:
      slackernews:
        pullSecret: repl{{ ImagePullSecretName }}
        repository: '{{repl HasLocalRegistry | ternary LocalRegistryHost "proxy.replicated.com" }}/{{repl HasLocalRegistry | ternary LocalRegistryNamespace (print "proxy/" (LicenseFieldValue "appSlug") "/ghcr.io/slackernews" ) }}/slackernews-web:1.0.17'
```

Let's break down these two values to understand why we need all this template
logic (especially since your default Helm values might already take the proxy
into account).

First, we set the `images.slackernewws.pullSecret` value to `repl{{ ImagePullSecretName }}`.
This grabs the image pull secret created by the Admin Console and lets the
chart know to use it when pulling the SlackerNews image. In [Protecting Your
Assets](https://play.instruqt.com/manage/replicated/tracks/protecting-your-assets),
you configured your own secret. In an online installation, the values in the
secret will be identical. When your customer chooses an airgap installation,
they'll be different. The secret you configured will contain credentials for
the proxy, while the secret created by the Admin Console will contain credentials to the registry
inside the airgap.

Likewise, the `LocalRegistryHost` and `LocalRegistryNamespace` functions refer
to the registry inside the airgapped environment. Using the `HasLocalRegistry`
function, you can distinguish between the online scenario (where you provide
the proxy service URI) and the airgapped scenario (where the Admin Console
fills in the details).

Providing a Complete Set of Values
==================================

Like with the last step of the lab, there's a more robust set of values needed
than just the ones we went through. To include the complete set of values in
your release, move the file `complete-helmchart.yaml` in your home directory
into the `release` directory.

```shell
mv complete-helmchart.yaml release/slackernews-chart.yaml
```

Releasing an Update
===================

We now have a complete release of the SlackerNews application that a customer
can install. Let's release our update and move it through the release process.

Like our last release, we're going to bump the Helm chart version to keep the
versions aligned across all our install methods. Remember this is optional, so
if you feel funny bumping the chart version when you didn't change the chart
itself you can skip that part. In practice you'll usually be making changes to
both the chart and the Embedded Cluster installer configuration in parallel so
this probably won't be an issue.

Run the following commands to bump the chart version and add it to your
release.

```
yq -i '.version = "0.6.2"' slackernews/Chart.yaml
helm package -u slackernews -d release
rm release/slackernews-0.6.1.tgz
```

The `HelmChart` object needs to refer to the new chart version, so we need to
line up the version as well.

```
yq -i '.spec.chart.chartVersion = "0.6.2"' release/slackernews-chart.yaml
```

Now we can create our release and simulate a full release process by promoting
across the `Unstable`, `Beta`, and `Stable` channels. First build the release
and promote it directly to `Unstable`.

```
replicated release create --promote Unstable --yaml-dir ./release --version 0.6.2 \
  --release-notes "Collects configuration from the user and provides it to Helm"
```

Then you can promote to `Beta` using the release sequence from the output.

```
replicated release promote 9 Beta --version 0.6.2 \
  --release-notes "Collects configuration from the user and provides it to Helm"
```

And on to `Stable`

```
replicated release promote 9 Stable --version 0.6.2 \
  --release-notes "Collects configuration from the user and provides it to Helm"
```

Next, we'll see what your customer experiences when they install the
application.
</file>

<file path="delivering-as-an-appliance/05-downloading-and-installing/assignment.md">
---
slug: downloading-and-installing
id: fyep0ya3ekfg
type: challenge
title: Downloading and Installing with the Embedded Cluster Installer
teaser: |
  Install your application the way your customer will
notes:
- type: text
  contents: |
    How a customer installs with a Kubernetes appliance
tabs:
- id: xcd7qgygxvse
  title: Shell
  type: terminal
  hostname: node
- id: txnaghgwr6xj
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 1200
---

Now that we've prepared SlackerNews for an Embedded Cluster installation,
let's go through the experience a customer has installing it. Installation
happens in two parts:

1. A command-line download and install that creates a cluster
   running the Replicated Admin Console
2. A GUI experience facilitated by the Admin Console that installs
   your application.

Let's go through the first of these steps. We'll do the second in the next
section of the lab.

Getting the Install Instructions
================================

Each customer has their own unique download for the Embedded Cluster installer
The download includes installer binary, their license, and, for airgap
installs, the airgap bundle containing all required container images. Let's
connect to the Replicated Vendor Portal and get the download instructions for
our customer "Nitflex".

Select the "Vendor Portal" tab and log in with the following credentials:

Username: `[[ Instruqt-Var key="USERNAME" hostname="node" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="node" ]]`

Once you're logged in, navigate to the "Customers" page and find the customer
"Nitflex." Click on the name "Nitflex" then select "Manage customer" to see
the customer details and entitlements. We need to enable license options
for Nitflex to be able to use the Embedded Cluster installer.

There are a few license options that affect Embedded Cluster installations:

1. **KOTS Install Enabled** This option enables installing applications with
   the Admin Console (powered by Replicated KOTS), which is used as part of
   the Embedded Cluster installation.
4. **Airgap Download Enabled** Allows the customer to download the air-gapped
   version of the Embedded Cluster installer.
2. **Support Bundle Upload Enabled** Configures their license to allow
   uploading support bundles directly from the Admin Console for an online
   installation.
2. **Allow Snapshot** Includes components for application-level [backup and
   restore](https://docs.replicated.com/vendor/snapshots-overview).
2. **Embeded Cluster Enabled** Allows the customer to download the Embedded
   Cluster installer and install an Embedded Cluster instance.
4. **Allow Disaster Recovery** Provides disaster recovery functionality for
   the Embedded Cluster installation.

We don't need all of these options for this lab. We'll just enable the two
that we require: "KOTS Install Enabled" and "Embedded Cluster Enabled". Scroll
down to "License options" make sure both are active. You'll need to enable
KOTS first.

![Setting license options for the Embedded Cluster installation](../assets/embedded-cluster-license-options.png)

Once you've enabled the options, click "Save changes" and scroll back to the
top of the page. You may have noticed a button that said "Helm Install
Instructions" earlier. It's now changed to a menu for "Install instructions".
Select "Embedded Cluster" to see the instructions to download and install.

![Embedded Cluster Install Instructions](../assets/embedded-cluster-install-instructions.png)

Running the Installer
=====================

You can use the instructions from the Vendor Portal to download and install
SlackerNews using the Replicated Embedded Cluster. Select the "Shell" tab and
enter the download command from the vendor portal.

```bash
curl -f https://replicated.app/embedded/[[ Instruqt-Var key="REPLICATED_APP" hostname="node" ]]/stable \
    -H "Authorization: [[ Instruqt-Var key="LICENSE_ID" hostname="node" ]]" \
    -o [[ Instruqt-Var key="REPLICATED_APP" hostname="node" ]]-stable.tgz
```

This will download a tarball including the installer binary and the license
file for Nitflex. Extract the tarball to access the installer.

```bash
tar -xzvf [[ Instruqt-Var key="REPLICATED_APP" hostname="node" ]]-stable.tgz
```

Then run the installer:

```bash
sudo ./[[ Instruqt-Var key="REPLICATED_APP" hostname="node" ]] install --license license.yaml
```

The installer will prompt you for a password for the Admin Console. You can
enter any password you'd like, but you'll need to remember it when you log in
later. You can copy/paste the password below if you aren't feeling inspired.

```
[[ Instruqt-Var key="ADMIN_CONSOLE_PASSWORD" hostname="node" ]]
```

The installer starts by converting the machine you're running on into a single
node Kubernetes cluster. It will then install several components that support
Embedded Cluster operation, including the Admin Console that you'll use
to configure and install the application. You'll see a message and a spinner as each step
runs, replacing it with a checkmark when it completes.

```
? Set the Admin Console password: *********
? Confirm the Admin Console password: *********
✔  Host files materialized!
✔  Host preflights succeeded!
✔  Node installation finished!
✔  Storage is ready!
✔  Embedded Cluster Operator is ready!
✔  Admin Console is ready!
✔  Additional components are ready!
Visit the Admin Console to configure and install slackernews-rzx7ikjdtlno: http://10.5.1.34:30000
```

Once the installer completes, you'll see a message telling you to acccess the
Admin Console to configure and install SlackerNews. You customer will
copy/paste the URL from the output. You can access it directly in the next
step of the lab.
</file>

<file path="delivering-as-an-appliance/06-completing-the-install/assignment.md">
---
slug: completing-the-install
id: am2hqdznfpff
type: challenge
title: Completing the SlackerNews Installation
teaser: |
  Complete installing SlackerNews with the Admin Console
notes:
- type: text
  contents: |
    Let's walk through the rest of the installation
tabs:
- id: i1b6db1hruhx
  title: Admin Console
  type: website
  url: http://node.${_SANDBOX_ID}.instruqt.io:30000
  new_window: true
- id: omi9odffx8es
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 1200
---

We're part way through the installation of SlackerNews as a Kubernetes
appliance. We've run the SlackerNews installer which has create a single-node
Kubernetes cluster running all of the infrastructure components of the
Replicated Embedded Cluster. The next step is to complete the install using
one of those components, the Admin Console.

About the Admin Console
=======================

The Replicated Admin Console is a web-based interface that plays two major
roles:

1. It wraps the Helm command with a user-friendly interface that guides the
   user through the installation process.
2. It offers a GUI for "Day Two" operations like checking for (and installing)
   updates, collecting support bundles, and managing cluster nodes.

We're going to focus primarily on the first role for now.

Completing the Install
=====================

To help us complete our installation, the Admin Console will guide us
through a few steps, starting with configuring its certificate. Since it's
not possible to provide a "safe" certificate to the Admin Console out of the
box, the process starts with a warning and instructions for the user to
validate the self-signed certificate the installer created.

![Explaining the Initial Certificate to Your Customer](../assets/certificate-warning.png)

The next step will ask your customer to configure the permanent certificate
for the Admin Console. They can choose between a self-signed certificate or
uploading one signed by a certificate authority. Replicated recommends that they use a
signed certificate, this is something you may also want to suggest in your
installation documentation.

For the lab, though, we'll stick with the self-signed certificate. When you
click the "Continue to Setup" button, you'll get a warning about the initial
self-signed certificate. Assuming you accept the risk, you'll get a form that
allows you to set up the SlackerNews Admin Console certificate. Keep it set on
"self-signed" and click "Continue".

![Configuring the Admin Console Certificate](../assets/certificate-configuration.png)

You'll be asked to log into the Admin Console on the next page. The password
for the Admin Console is the password you specified in the last step. It will
be `[[ Instruqt-Var key="ADMIN_CONSOLE_PASSWORD" hostname="node" ]]` if you use the suggestion
from the lab text or skipped ahead to this step.

### Adding Nodes to the Cluster

The first thing you'll see when you log in to the Admin Console is the Node
Management screen. This is where you can add additional nodes to the
cluster embedded with SlackerNews. Node management is the first step in the install
process because not all applications can run on a single node.

![Admin Console Node Managemet Interface](../assets/node-management.png)

To simplify this lab, we're going to stick with a single node cluster. Click
"Continue" to continue the installation on one node. SlackerNews is a fairly
lightweight application and can run fairly easily on a single node.

### Configuring Your Instance

Next is the configuratiion screen that we defined earlier. Fill in the values
for each entry.

![Entering the SlackerNews Configuration in the Admin Console](../assets/providing-configuration.png)

The first two sections are fairly straightforward:

* **SlackerNews Domain**: `[[ Instruqt-Var key="SLACKERNEWS_DOMAIN" hostname="node" ]]`
* **Admin Users**: `[[ Instruqt-Var key="ADMIN_EMAIL" hostname="node" ]]`
* **Service Type**: NodePort
* **Node Port**: `30443`
* **Certificate Source**: Generate

The next section presents us with a bit of a challenge. We don't have a Slack
team to connect to, so any values we enter will be invalid. The values are
required, though, so we need to enter something. Let's use the following placeholder
values:

* **Slack Client ID**: `notavalidid`
* **Slack Client Secret**: `notavalidsecret`
* **User OAuth Token**: `xoxp-notavalidtoken`
* **Bot User Auth Token**: `xoxb-notavalidtoken`

Note that we prefixed the two tokens. Those are the prefixes used by actual Slack
tokens. We needed to do this to pass the validation on those fields.

Click "Continue" to move to the next steps and run our preflight checks.
Preflight checks run after your customer specifies their configuration so that
you can use the configuration values as part of your checks.

### Running Preflight Checks

The Admin Console will run preflight checks it finds in the release. Preflight
checks are resources processed by the Admin Console to ensure that your
customer has met the prerequisites to successfully install your application.
They can be included as standard manifests within the Embeddded Cluster
release or as secrets within your application's Helm chart.

We strongly recommend including them in your Helm chart so that they can be
used regardless of installation method. See [Avoiding Installation
Pitfalls](https://play.instruqt.com/manage/replicated/tracks/avoiding-installation-pitfalls)
for more details on writing preflight checks and including them in your
application.

We didn't add any preflight checks in this lab because the SlackerNews Helm
chart already includes them. They check for some basic prerequisites:

1. The version of Kubernetes is one that the SlackerNews team is prepared to
   support. This is a less relevant check for an Embedded Cluster installation
   since the version of Kubernetes is tightly coupled to the application
   release, but it's critical when installing into an existing cluster.
2. Access to the Slack API. This is probably the most critical check for the
   SlackerNews application. The application provides no value if it cannot
   connect to Slack, and a lot of production servers are configured to limit
   access to the internet. This check will fail if the server cannot connect
   and will provide guidance on how to resolve the issue.
3. The amount of memory available in the cluster. SlackerNews is not terribly
   resource intensive, but this is a good check for most applications and the
   SlackerNews team wants to make sure they have space to run.

All of your checks should pass, and you should see a screen like the one
below. Click "Deploy" to continue.

![Successful SlackerNews Preflight Checks](../assets/successful-preflight-checks.png)

If one or more check had failed or provided a warning, you may still have had
the option to continue the deployment. You can decide when writing your
preflight checks whether a failure stops a deployment or allows it to
continue.

### Validate the Installation is Running

The Admin Console played a little trick on you. Since all of your preflight
checks passed it continued the installation without waiting for you to click
"Deploy". This means that the instance might be running successfully
when you land on the main Admin Console screen. Otherwise, just wait until you
see the status change to "Ready" underneath the title "SlackerNews".

![SlackerNews Admin Console with "Ready" Status](../assets/slackernews-admin-console-ready.png)

While you're connected to the Admin Console, notice some of its other
capabilities:

* You can manage the cluster nodes using the "Cluster Management" tab.
* You can use the "Troubleshoot" tab to collect and analyze support bundles
  defined as part of the application.
* You can reconfigure the application using the "Config" tab.

Each of these is beyond the scope of the current lab, but feel free to poke
around at them before you move on.

Your Perspective on the Install
===============================

You've just run through the customer experience of installing SlackerNews with
the Replicated Embedded Cluster. Before we wrap up the lab, let's take a
moment to see the how this new instance looks on the Replicated Vendor portal.
Knowing what happened when your customer installed is an important piece of
information for you as as software vendor.

Use the "Vendor Portal" tab to connect to the Replicated Vendor Portal. You may
still be logged in from the previous step. If not, log in again
with the following credentials:

Username: `[[ Instruqt-Var key="USERNAME" hostname="node" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="node" ]]`

Navigate to the "Customers" page in the left hand menu and you'll see that
Nitflex has a new instance of the application running.

![Customer Page Showing New Running Instance for Nitflex](../assets/new-nitflex-instance.png)

Click in on the instance name to see details about the instance. You not only
see information about what version of your application they are running, but
also details about their preflight checks, the details of the cluster, even
the cloud provider. This information can be useful to your support and product
teams as the support the customer journey and evolve your product.

![Instance Details for the New Nitflex Instance](../assets/new-nitflex-instance.png)

🏁 Finish
=========

You've now successfully built and installed a Kubernetes appliance with
Replicated Embedded Cluster. You've seen how the Admin Console guides the
installation and had a look at what features it supports. Your current
installation of SlackerNews runs on a single-node cluster, but you've seen how
your customer could expand it to have additional nodes.
</file>

<file path="distributing-with-replicated/01-preparing-to-use-the-sdk/assignment.md">
---
slug: preparing-to-use-the-sdk
id: ulkfmbpkhe3y
type: challenge
title: Preparing to Use the SDK
teaser: Getting ready to use the Replicated SDK
notes:
- type: text
  contents: Let's get ready to use the Replicated SDK
tabs:
- id: oaa7v3tv4y1k
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 300
---

👋 Introduction
===============

The Replicated SDK is implemented as a small service that runs
alongside your application and enables access to the Replicated
Platform. The SDK allows you to enforce your entitlements and
take advantage of the telemetry that Replicated provides to help
you better understand customer instances. It also allows you
to get information about your application and its releases,
including checking for updates and showing version history.


✅ Preparing to use the SDK
===========================

To make use of the Replicated SDK, you'll need a couple of
things. They've been set up for you in this lab environment.

1. A Helm chart for your application. We're going to use the
   chart for [Slackernews](https://slackernews.io), an application
   Replicated created to showcase our platform.
2. Access to the Replicated Vendor Portal. You've been given
   access for the duration of this lab with the username
   `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]` and
   the password `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`
3. An application on the Replicated Vendor Portal. It was also
   created for you as part of the lab setup.
4. A customer for that application. The automation created the
   customer as well.

🔤 Getting Started
==================

To use the SDK, we need to add a dependency to the Slackernews
Helm chart. The chart sources are in the directory `slackernews` in
your home directory.

Let's also set up our shell for interacting with the Replicated
platform.

```
export REPLICATED_API_TOKEN="[[ Instruqt-Var key="REPLICATED_API_TOKEN" hostname="shell" ]]"
```

And lastly make sure we are working with the Slackernews app that was
created by the lab setup.

```
export REPLICATED_APP="[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]"
```
</file>

<file path="distributing-with-replicated/02-enabling-the-sdk/assignment.md">
---
slug: enabling-the-sdk
id: 9weportqrwy6
type: challenge
title: Enabling the Replicated SDK
teaser: Incorporate the SDK into your application
notes:
- type: text
  contents: Introducing the Replicated SDK into your application
tabs:
- id: lep5xpebtpkw
  title: Shell
  type: terminal
  hostname: shell
- id: cnhzcdcy5ots
  title: Manifest Editor
  type: code
  hostname: shell
  path: /home/replicant
difficulty: basic
timelimit: 300
---

Now that we've got our environment set up, let's incorporate the
SDK into our application. Replicated makes it easy for you to do
this by providing a Helm chart you can drop into your chart as a
dependency. When you deliver your Helm chart from the Replicated
registry, we'll embed your customer's license into the final
chart.

This injection serves a few purposes:

1. The license is available to your application logic through a
   call to an API provided by an in-cluster service.
2. Access to your container images and other registry
   assets is secured using customer-specific credentials
3. The in-cluster service can connect securely to the Replicated
   vendor portal for telemetry, upgrade checks, etc.

Adding the Dependency
======================

Go to the the "Manifest Editor" tab and edit the file `Chart.yaml` in
the source directory `slackernews`. You're going to make two changes to
this file.

First, you're going to add a dependency on the Replicated SDK Helm
chart.

```
- name: replicated
  repository: oci://registry.replicated.com/library
  version: [[ Instruqt-Var key="REPLICATED_SDK_VERSION" hostname="shell" ]]
```

You should put the dependency into the array with any other chart dependencies.
In this case, we don't have any dependencies so we need to add the key
`dependencies` to the YAML file. Use the version shown above, since it may be
newer than the one in the screenshot.

![Adding the Dependency](../assets/adding-the-dependency.png)

You should also bump the version number of your chart. Adding
telemetry and preparing to distribute with Replicated feels like
a fairly large change. It's not a breaking change, though, so
let's just bump the minor version number.

```
version: 0.2.0
```

![Bumping the Chart Version](../assets/bumping-the-version.png)

After you make each change, the editor will automatically save
them. Be sure they are saved before you continue.

![Assuring Your Changes are Saved](../assets/saving-your-changes.png)

After saving, drop back in to the "Shell" tab and update your
dependencies.

```shell
helm dependency update slackernews
```

Repackaging Your Chart
=====================

After updating dependencies, you should repackage your Helm
chart into a new tarball including the changes.

```
helm package slackernews --destination ./release
```

You should now have a tarball in directory `release` in your
home directory.

```
ls release
```

which shows

```
slackernews-0.2.0.tgz
```
</file>

<file path="distributing-with-replicated/03-creating-a-release/assignment.md">
---
slug: creating-a-release
id: vxnhm8nlkifh
type: challenge
title: Releasing an Application
teaser: Creating a release on the Replicated Platform
notes:
- type: text
  contents: It's time to distribute our application with Replicated
tabs:
- id: y93opy8anppl
  title: Shell
  type: terminal
  hostname: shell
difficulty: basic
timelimit: 300
---

To take advantage of the Replicated Platform to distribute
an application, we need to let the platform know about the
application, its releases, and the customers who are entitled
to access it. The lab environment has created the
Slackernews application for us, and created a customer, "Omozan",
that has access to it. All we need to do is create a
release and we'll be ready to go.

Replicated Release Channels
===========================

There's one more part of the equation that we didn't mention
above. The Replicated Platform provides a way to connect
each customer to the right release(s) for them. It does this
by organizing releases into _channels_, and assigning each
customer license to the appropriate channel.

We encounter this concept in our day-to-day use of software
all the time. For some applications, you sign up to
receive beta releases, while others you may receive updates only
when they're GA. You may even have some software, for example
your Linux distribution, where you use only releases that
have long term support.

Release channels help you account for the different release
cadences of your software. By default, Replicated creates
three release channels for each application.

```
replicated channel ls
```

You should see three channels in the output:

* `Unstable` is, as it sounds, releases that may be unstable
   and subject to defects and/or constant change. You may have
   every merge PR hit this channel, for example.
* `Beta` represents releases that have beta quality, for
  the customers you have as part of a beta program for new
  releases.
* `Stable` is for GA releases that you want to be broadly available
  to your customer base. This would be the default
  channel for any customer who did not opt-in to an alternative.

You may consider a few other uses for release channels in your
release process. For examples, let's add a channel called `LTS`
for those customers who want longer term guarantees of
support and fitness that you provide for your standard releases.

```
replicated channel create --name LTS \
  --description "Releases with long-term support available"
```

Other examples:

* `Edge` for customers who want continuous delivery of your
   software to their environments.
* Channels named after the feature branches in your source
  code. These can help product teams validate releases before
  they are merged for release on your primary channels.
  Replicated recommends all teams follow this approach.

Creating Your Release
=====================

To create a release, run the following command. We're using the
`Unstable` channel since we're releasing our most recent change.

```
replicated release create --promote Unstable --chart ./release/slackernews-0.2.0.tgz --version 0.2.0  \
  --release-notes "Prepares for distribution with Replicated by incorporating the Replicated SDK"
```

This creates a release for version `0.2.0` of your Slackernews Helm
chart, and promotes it to the `Unstable` channel.  The `create`
command output a sequence number that you'll need for `promote`
(it will be `1` if you haven't explored releasing a bit more).

```
  _ Reading manifests from ./release _
  _ Creating Release _
    _ SEQUENCE: 1
  _ Promoting _
    _ Channel 2Qa7rGeBiT3DaDK85s6FVKRC7Mn successfully set to release 2
```

The sequence number uniquely identifies a release among all the
releases you've made for your application. You can list your
releases using

```
replicated release ls
```

which should show the initial release created during lab
set up, as well as the release you just created. It will
also show the channel each release is currently available on,
if any.

```
SEQUENCE    CREATED                 EDITED                  ACTIVE_CHANNELS
1           2023-06-08T00:23:40Z    0001-01-01T00:00:00Z    Unstable
```

To make an existing release available on another channel, use
`replicated release promote`. In your actual release process,
there may be a lot of activity between releasing to `Unstable`,
promoting to `Beta`, and ultimately releasing on `Stable`.
For the purposes of the lab, let's just promote the release straight through.

```
replicated release promote 1 Beta --version 0.2.0 \
  --release-notes "Prepares for distribution with Replicated by incorporating the Replicated SDK"
```

and then

```
replicated release promote 1 Stable --version 0.2.0 \
  --release-notes "Prepares for distribution with Replicated by incorporating the Replicated SDK"
```

You can see they were promoted by listing your releases again. You should see
similar output to the following:

```
SEQUENCE    CREATED                 EDITED                  ACTIVE_CHANNELS
1           2023-06-08T00:23:40Z    0001-01-01T00:00:00Z    Stable,Beta,Unstable
```
</file>

<file path="distributing-with-replicated/04-installing-the-application/assignment.md">
---
slug: installing-the-application
id: 7tugkh1lkicg
type: challenge
title: Installing the Application
teaser: Let's install the application as your customer
notes:
- type: text
  contents: Let's see how your customer installs an application
tabs:
- id: blzkxyy5ocbs
  title: Shell
  type: terminal
  hostname: shell
- id: gkzlk56yrgvt
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 600
---

Now that we have a release in the Replicated Platform, you can
distribute its Helm chart to your customers using entitlements
that we manage for you. In this step, we're going to install the
Slackernews Helm chart the same way a customer would install your
application.

Logging Into the Vendor Portal
==============================

We're going to use the Replicated Vendor Portal to look up the
installation instructions for the customer "Omozan". The Vendor
Portal is a core interface into the platform. We'll use it again
later in this lab to review the telemetry information we receive
from the SDK.

Click on the Vendor Portal tab to open up a new browser window and
access the portal. Log in with these credentials:

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

You'll land on the "Channels" page for your app, which will show
the release channels we discussed in the previous step. Notice that
each channel shows the current version `0.2.0` while the channel LTS, which we haven't released to, reflects
that.

![Vendor Portal Release Channels](../assets/vendor-portal-landing.png)

_Note: If you are already a user of the Replicated Vendor Portal
you may need to log out using the settings menu in the top right
corner before you can log in as the lab user._

Getting the Install Instructions
================================

Installation instructions are specific to each customer, since they
require unique login credentials for the Replicated registry. We're
going to install as the customer "Omozan" that has been set up as
part of the lab.

Select the "Customers" link from the left navigation. You'll end up on
the Customers landing page.

![Customers Landing Page](../assets/customers-page.png)

You'll see the list of customers, with the customer
"Omozan" as the only one in the list. Click on their name and you'll
be brought to their customer page. In the top right corner you'll
see a link to their install instructions.

![Customers Landing Page](../assets/single-customer-page.png)

Click on the link. Normally, if you had not configured your customer's email yet, you would first be prompted to enter a customer
email. However, we have already done this as part of the lab set up, so you should see the install instructions for the customer.

![Install Instructions](../assets/helm-install-instructions.png)

You're going to use these instructions to complete your install.
We'll skip the preflight checks for this lab since we haven't
added any to our chart.

Installing the Application
==========================

Your customer starts their installation by logging into our
registry with the `helm` command. This gives them access to
your Helm chart via the Replicated Platform.

```
helm registry login registry.replicated.com \
  --username [[ Instruqt-Var key="CUSTOMER_EMAIL" hostname="shell" ]] \
  --password [[ Instruqt-Var key="REGISTRY_PASSWORD" hostname="shell" ]]
```

From there, they do a simple Helm install. In our case, we're going to
tack some additional values that Slackernews needs to come up correctly.
This helps us make sure the installation is complete before we move
onto the next step in the lab.

```
helm install --namespace slackernews --create-namespace  \
    slackernews \
    oci://registry.replicated.com/[[Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews \
    --set slackernews.domain=[[ Instruqt-Var key="SLACKERNEWS_DOMAIN" hostname="cluster" ]] \
    --set service.type=NodePort
```

It's normal for this command to take a little bit of time to
complete as various components of Slackernews come up.
</file>

<file path="distributing-with-replicated/05-validating-the-install/assignment.md">
---
slug: validating-the-install
id: gx3ctjxdgybf
type: challenge
title: Observing the Customer Instance
teaser: Observing your customer install
notes:
- type: text
  contents: Gaining insight into your customer's instance
tabs:
- id: 4dolm9ekmzcn
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 600
---

Now that we've installed the application the way your customer
will, let's turn back to your perspective on what's going on
in their environment. We're going to log back into the Vendor
Portal in order to check the status of Omozan's instance.

Logging Into the Vendor Portal
==============================

We're going to return to the Replicated Vendor Portal to look
at the details on the current instance. Click on the Vendor
Portal tab to open up a new browser window and access the
portal. You may still be logged in. If not, log in with these
credentials:

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

Observing the Customer Instance
===============================

Instance Insights is a feature of the Replicated Vendor Portal
that provides you detailed insights into the experience your
customer is having with your applications. It is automatically
available when you include the Replicated SDK in your application.
The SDK sends telemetry events to the Vendor Portal to reflect
details about the application, the cluster it's running on, and
current health indicators.

We're going to go to the Instance Insights page for the instance we
just installed by navigating from the Vendor Portal landing page.
If you look at the _Stable_ channel, you'll see there is one
active customer indicated.

![Active Customer in Stable Channel](../assets/active-customer-in-channel.png)

If you click on "Details" you'll be brought to a filtered view of
the Customers page showing all customers that are entitled to releases
on the _Stable_ channel. You'll see the customer "Omozan" there, and
you'll notice it shows one instance. The specific status of the
instance will depend on how quickly you navigated to the page after
starting the install.

![Stable Channel Customer List](../assets/stable-channel-customers.png)

Click on the name "Omozon" to see more information about Omozan
and their instances, then click on the instance identifier
for the one instance you see.

![Omozan Customer Page](../assets/omozan-customer-page.png)

Reviewing Instance Activity
===========================

Once you've clicked on the instance identifier, you'll see more
details about that instance, including recent activity. The instance
will be in either a _Ready_ state, a _Missing_ state, or an
_Unavailable_ state depending on the progress of your installation.
If it is not yet ready, watch for a minute or two and
you'll see the status change to "Ready."

![Customer Instance Details](../assets/instance-details.png)

🏁 Finish
=========

Once Omozan's instance is in the _Ready_ state, you've successfully
distributed the application to the customer "Omozan" using the
Replicated Platform.
</file>

<file path="protecting-your-assets/01-the-replicated-license/assignment.md">
---
slug: the-replicated-license
id: frbo6izjilr1
type: challenge
title: The Replicated License
teaser: Understanding the role of the Replicated license
notes:
- type: text
  contents: Understanding the Replicated license
tabs:
- id: koeopqurczds
  title: License File
  type: code
  hostname: shell
  path: /home/replicant
difficulty: basic
timelimit: 400
enhanced_loading: null
---

👋 Introduction
===============

The Replicated Platform provides a license that identifies each of your
customers and entitles them to install your software. These customer licenses
provide several default entitlements such as the type of license and whether
(and when) it expries. Replicated provides the license file to you as a
downloadable asset and embeds it into your Helm chart when you include the
Replicated SDK. A digital signature confirms it hasn't been tampered with.

How Licenses Work
================

Each customer you create for your application in the Replicated Vendor Portal
has a license associated with it. The main purpose of the license is to
identify which software the user is entitled to. The entitlement is determined
by two attributes of the license: the application and the release channel. The
platform knows the application the customer was created for, and you specify
the release channel when you create the customer. You can change the channel at
any time. We'll discuss release channels shortly.

The other core attribute of the license is its type. Each customer license has
one of the following types:

* **Development:** The Development type can be used internally by the
  development team for testing and integration.
* **Trial:** The Trial type can be used for customers who are on 2-4 week
  trials of your software.
* **Paid:** The Paid type identifies the customer as a paying customer for
  which additional information can be provided.
* **Community:** The Community type is designed for a free or low cost version
  of your application.

You can change the license type of an existing license. You'll most often do
this when a customer who has been trying your software decides to make a
purchase.

The other common features of all licenses are an expiration date and flags for
enabling several Replicated Platform features. Licenses need not expire, and you
have full control over the expiration date that you set. Replicated features
may change over time and have sensible defaults based on your subscription.

Release Channels
================

Before we create our first customer, let's briefly discuss release channels.
If you've completed another lab like [Avoiding Installation
Pitfalls](https://play.instruqt.com/replicated/tracks/avoiding-installation-pitfalls)
or [Closing the Support Information
Gap](https://play.instruqt.com/replicated/tracks/closing-infromation-gap) then
you may already be familiar with them. If you haven't, then here's a quick introduction.

The [Distributing Your Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-with-replicated)
lab covers release channels in the most depth if you'd like more information.

Release channels, at their most basic, map releases to customers. Each customer
is assigned to a specific channel, and any relase can be provided to as many
channels as you want. There are three default channels: `Unstable`, `Beta`, and
`Stable`. Think of `Stable` as your GA software and `Unstable` as releases that
you're planning to test and/or distribute internally. `Beta` is, of course, for
beta releases.

Those are the defaults, but you can have as many channels as you like. Some
vendors drop one of the defaults and only have two channels, while others add
channels for additional stages in the software lifecycle like `Alpha` or `Long
Term Support`. Your team should consider the right set of release channels as
you work through your implementation.

License Files
=============

The customer license is defined in a format that's easy both to read and to
parse.  A basic license is in the file `Geeglo.yaml` that you can open in the
editor showing in the "License File" tab. You'll notice that it's a YAML
formatted file with the same structure as a Kubernetes object. The object is
interpreted by the Replicated Platform components rather than the Kubernetes
cluster to avoid needing any special permissions.

![Opening the Geeglo License File](../assets/opening-the-license-file.png)

In most installation scenarios, neither you nor your customer will need to
interact directly with their license file. Instead, the platform embeds it into
install artifacts like the your Helm chart and the Replicated Embedded Cluster
binary. The exception is installing into an existing cluster using the
Replicated Admin Console. The console will prompt for the customer to upload
their license as one of the first steps to the install.
</file>

<file path="protecting-your-assets/02-create-a-customer/assignment.md">
---
slug: create-a-customer
id: f0ayvnopkkyv
type: challenge
title: Creating a Customer License
teaser: Time to add a customer and configure their license
notes:
- type: text
  contents: |
    Add a customer to your application and configure their license
tabs:
- id: x9hlwddp7jly
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
- id: gqxwmse9cfru
  title: Shell
  type: terminal
  hostname: shell
  workdir: /home/replicant
difficulty: basic
timelimit: 600
enhanced_loading: null
---


Creating a Customer License
===========================

Let's connect to the Replicated Vendor Portal and create a new customer. This
will also create their license. Click on the "Open External Window" button to
open a new browser window and access the portal. Log in with these credentials:

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

You'll land on the "Channels" page showing the default release channels and an
added channel for releases with long-term support.

![Vendor Portal Release Channels](../assets/vendor-portal-landing.png)

To create a customer, select "Customers" from the menu on the left, and you'll
see your two existing customers "Omozan" and "Geeglo".

![Your Existing Customers](../assets/customer-landing-page.png)

We're going to assume you're working with a new prospect named "Nitflex" and
create them in the portal. The platform also includes an
[API](https://replicated-vendor-api.readme.io/v3/reference/createapp) you can
use to automate customer creation as part of your existing onboarding workflow.
For the purpose of the lab, click the "+ Create Customer" button to create
"Nitflex" manually.

![Creating a Customer](../assets/create-customer-button.png)

Enter the name "NitFlex" and assign them to the `Stable` channel. They'll be
trying your software for two months, so let's make sure we capture the expiration
date. We also need an email for them to login and install your Helm chart. Note
that we never use that email, it's your customer, not ours.

Expiration Date: `[[ Instruqt-Var key="LICENSE_EXPIRY" hostname="shell" ]]`<br/>
Customer Email: `[[ Instruqt-Var key="CUSTOMER_EMAIL" hostname="shell" ]]`

![Customer Details](../assets/new-customer-details.png)

You should also specify that they are a trial customer, so select the "Trial"
option for the customer type and save your changes. The process will be
the same for a new paid customer with a longer expiration date and a "Paid"
license type.

Lastly, be sure to specify the type of installations they are allowed to
make. Choose "Existing Cluster (Helm CLI)" and save your changes.

![Install Types](../assets/install-types.png)

Using the License
=================

The Vendor Portal generated a license for your Nitflex customer and also
configured some credentials based on it. These credentials are for:

* The Replicated registry for accessing the Slackernews Helm chart
* The Replicated proxy registry that protects your private images

Let's use the first set of credentials to look at how the license is embedded
into your Helm chart.

Click on "Helm install instructions" and you'll see a popup with a set of
instructions for this customer to install Slackernews. The first command is the
login command for the Replicated registry.

![Helm Login Command](../assets/helm-login-command.png)

Use the "Shell" tab in the lab to log into the registry. You'll need to copy
the command from the vendor portal in order to log in. after you login, you can
view the values for the Helm chart using `helm show values`:

`helm show values oci://registry.replicated.com/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews | less`

This will show you the default vales from the Helm chart. As you scroll through
the values, you'll see license information injected in two places. The entire
license file is injected as the `license` value for the `replicated` subchart,
and a few details from it are injected under `.global.replicated`.

One of the global fields is particularly important. The value
`global.replicated.dockerconfigjson` has the required Docker configuration to
access private images using the proxy registry. You will use this value in your
Helm chart to give the cluster access to your private images.
</file>

<file path="protecting-your-assets/03-proxying-private-images/assignment.md">
---
slug: proxying-private-images
id: ui20iijaawgo
type: challenge
title: Proxying Private Images
teaser: Protect your private container images with the Replicated proxy registry
notes:
- type: text
  contents: |
    Share your private images without exposting your private registry to your customers
tabs:
- id: poakxpyplmkr
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
- id: yxrpecqzosxy
  title: Slackernews Chart
  type: code
  hostname: shell
  path: /home/replicant
- id: 34ljfxan4eaw
  title: Shell
  type: terminal
  hostname: shell
  workdir: /home/replicant
difficulty: basic
timelimit: 600
enhanced_loading: null
---

One of the core features of the Replicated Platform is its proxy registry. The
proxy registry controls access to your images using the Replicated license.
This relieves you of the burden of managing authentication and authorization
for the private images your application depends on. You provide Replicated with
access and we manage the rest.

Configuring a Private Registry
==============================

The first step in using the Replicated proxy registry is to provide access to
your private registry for the Replicated Vendor Portal. This has already been
done in the lab environment, so we're just going to review how it was set.

You may still be logged into the Vendor Portal, but if you're not you can log
in with the following credentials:

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

From the "Channels" page you landed on, select "Images" in the left-hand menu.
You'll land on a page that shows that the proxy is configured to pull private
images from the GitHub Container Registry.

![Managing Images on the Vendor Portal](../assets/managing-images.png)

You use the "+ Add external registry" button to add a private registry. We won't
be doing this in the lab environment since it's a shared team.

Adding the Proxy to Your Chart
==============================

The next step to securing your images with the Replicated Platform is to use
the proxy to pull images. The Slackernews chart refers to its two images in
its default values. We'll change those to refer to the Replicated proxy
registry.

Image tags in the proxy registry follow the following pattern:

```
$PROXY_REGISTRY_HOST/proxy/$APP_SLUG/$ORIGINAL_IMAGE_TAG
```

so you'll proxy the image `ghcr.io/slackernews/slackernews-web:1.0.17` as

```
proxy.replicated.com/proxy/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/ghcr.io/slackernews/slackernews-web:1.0.17
```

for your instance of Slackernews. Let's do that now.

### Updating Image References

Select the "Slackernews Chart" tab in Instruqt to edit the chart source files. Select the
file `values.yaml` and search for the image values.

![Image Value Settings in Helm Chart](../assets/image-values.png)

Update the image values to use the proxied image for the main Slackernews
image

```
slackernews:
  repository: proxy.replicated.com/proxy/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/ghcr.io/slackernews/slackernews-web:1.0.17
```

Since we've made a change that will impact our users, let's also bump the
version number by editing `Chart.yaml` and setting a new chart version.

```
version: 0.5.0
```

The editor should have automatically saved your changes to both files.

Allowing Image Access
---------------------

The last change you need to make is to assure an appropriate image pull secret
is set on the pods that require access to proxied images. We need two things to
do this:

1. A template in our Helm chart to create the secret
2. Reference to the secret for any workloads that need it

Another good practice is to specify image pull secrets as Helm values, so we'll
plan on doing that as well.

The image pull secret provides registry credentials to pull images. An obvious
question to ask is how we know which credentials to use for the proxy registry.
Replicated takes care of this for us as part of the same process it uses to
inject the license file into your Helm chart. This process provides a global
value `replicated.dockerconfigjson` that contains the credentials.


We're going to go through the changes above backwards, since Slackernews has
already taken care of the second one. Open the `slackernews-deployment.yaml`
file under templates and look for the following lines that use the image pull
secret.

```
      {{ if hasKey ((.Values.global).replicated) "dockerconfigjson" }}
      imagePullSecrets:
        - name: replicated-pull-secret
```

This lines are only included if the global values provided by the Replicated
Platform are set. In other words the chart was pulled from the Replicated
registry. They reference a pull secret named `replicated-pull-secret`. Let's
create that secret.


Create a new file named `imagepullsecret.yaml` in the directory
`slackernews/templates` to include the secret in your chart.

![Creating the image pull secret](../assets/creating-the-image-pull-secret.png)

If the new file wasn't opened automatically, click on the filename to create
it. Add the following content to the file. This template uses a guard condition
to assure it's only included if the injected credentials are available.

```
{{ if hasKey ((.Values.global).replicated) "dockerconfigjson" }}
apiVersion: v1
kind: Secret
metadata:
  name: replicated-pull-secret
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: {{ .Values.global.replicated.dockerconfigjson }}
{{ end }}
```

The editor will automatically save your changes.

Distributing Your Changes
=========================

Let's release the changes so new installs will use the Replicated proxy
registry to access the Slackernews and NGINX images.

### Repackaging Your Chart

Since we changed the default values, we need to repackage our Helm chart.

```
helm package slackernews --destination ./release
```

You should now have a tarball in directory `release` in your
home directory named `slackernews-0.5.0.tgz`.

### Creating a New Replicated Release

To make the changes available, we need to release them on the Replicated
Platform. You'll need to be authenticated to the Replicated Platform to create
the new release. The simplest way to do that is by specifying an API token in
your shell environment. The lab setup has created a token for you.

```
export REPLICATED_API_TOKEN="[[ Instruqt-Var key="REPLICATED_API_TOKEN" hostname="shell" ]]"
```

The `replicated` command also needs to know which application to work with. You
can set it with a command flag or with an environment variable. Let's set the
variable to save some typing.

```
export REPLICATED_APP="[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]"
```

To create a new release, run the following command.

```
replicated release create --promote Unstable --chart ./release/slackernews-0.5.0.tgz --version 0.5.0  \
  --release-notes "Uses the Replicated proxy registry to pull images"
```

You may notice a message saying that this release is "helm only". The reason
for that is that the Replicated Platform supports multiple installation
methdods and some of them require additional files. Don't worry, the same
release can be used to support all of those approaches once the files are in
place.

This will not only create the release but push it to the `Unstable` release
channel on the platform. It will also output a sequence number, which should be
`5` (if it's not, use the number in the output for the upcoming commands).
We're going to release our changes on three different release channels in this
lab:

* `Unstable`: use for internal releases that aren't ready for customers
* `Beta`: for releases that are ready for beta testing
* `Stable`: the general availability channel for all releases

These are the default three channels on the Replicated Platform. To learn more
about release channels, take a look at the [Distributing Your Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-your-application-with-replicated)
lab.

### Promoting the Release

To make your release available to Beta and GA customers, promote it to those
channels.

```
replicated release promote 5 Beta --version 0.5.0 \
  --release-notes "Uses the Replicated proxy registry to pull images"
```

and then

```
replicated release promote 5 Stable --version 0.5.0 \
  --release-notes "Uses the Replicated proxy registry to pull images"
```

List your releases again to see that the release has been promoted.

```
replicated release ls
```

Your list of releases will now show four releases with the most recent release
available on the `Unstable`, `Beta`, and `Unstable` channels.

```
SEQUENCE    CREATED                 EDITED                  ACTIVE_CHANNELS
5           2024-04-22T17:19:17Z    0001-01-01T00:00:00Z    Stable,Beta,Unstable
4           2024-04-22T16:23:39Z    0001-01-01T00:00:00Z
3           2024-04-22T16:23:34Z    0001-01-01T00:00:00Z
2           2024-04-22T16:23:28Z    0001-01-01T00:00:00Z
1           2024-04-22T16:23:22Z    0001-01-01T00:00:00Z
```
</file>

<file path="protecting-your-assets/04-helm-values-for-license-fields/assignment.md">
---
slug: helm-values-for-license-fields
id: bhsmuyyhxvps
type: challenge
title: Using the License in Your Helm Chart
teaser: Working with the Replicated license values in your Helm chart templates
notes:
- type: text
  contents: Let's limit how the capabilities of a trial license for our application
tabs:
- id: h86j4ktlvfyu
  title: Shell
  type: terminal
  hostname: shell
  workdir: /home/replicant
- id: hh2yemo75vka
  title: Slackernews Chart
  type: code
  hostname: shell
  path: /home/replicant
- id: gcyi9rt0jaw7
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 600
enhanced_loading: null
---

When you distribute your software with Replicated, Replicated injects the
license into your Helm chart in two ways:

1. As a value provided to the Replicated SDK to access via an in-cluster API
2. As global values that you can use in other components, including directly in
   your Helm templates.

We're going to take advantage of the second option to update the Slackernews
chart to block installation if the license is expired.

### A Word of Caution

The approach we're demonstrating here is easily defeated by overriding a Helm
value on the command-line or in a values file. It's meant to remind an honest
customer their license is expired rather than prevent them from tampering in
order to install anyway. Additional features provided by the proxy registry and
the Replicated SDK should be used to assure compliance and prevent tampering.

Available License Values
========================

The global values provided by the Replicated registry are the most valuable to
use within your Helm chart. Let's take a look at our Slackernews license to see
what other information about the license is available. Log in to the Replicated
registry as your Nitflex customer.

```
helm registry login [[ Instruqt-Var key="REGISTRY_HOST" hostname="shell" ]]  --username [[ Instruqt-Var key="REGISTRY_USERNAME" hostname="shell" ]]  --password [[ Instruqt-Var key="REGISTRY_PASSWORD" hostname="shell" ]]
```

You can then view the values using the `helm show values` command. The command
below will get the values and isolate the globals. For Slackernews, this
will only include the values injected by the Registry.

```
helm show values oci://[[ Instruqt-Var key="REGISTRY_HOST" hostname="shell"]]/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews | yq -P .global
```

You'll see something like the following (the encoded fields and expiration will probably be
different).

```
replicated:
  channelName: Unstable
  customerEmail: [[ Instruqt-Var key="CUSTOMER_EMAIL" hostname="shell" ]]
  customerName: Nitflex
  dockerconfigjson: eyJhdXRocyI6eyJpbWFnZXMuc2hvcnRyaWIuaW8iOnsiYXV0aCI6Ik1tWlhSMVEzZDBGck0yOVVTbGhWY25GVWFrWlFUV0k1ZVV4dE9qSm1WMGRVTjNkQmF6TnZWRXBZVlhKeFZHcEdVRTFpT1hsTWJRPT0ifSwicmVnaXN0cnkuc2hvcnRyaWIuaW8iOnsiYXV0aCI6Ik1tWlhSMVEzZDBGck0yOVVTbGhWY25GVWFrWlFUV0k1ZVV4dE9qSm1WMGRVTjNkQmF6TnZWRXBZVlhKeFZHcEdVRTFpT1hsTWJRPT0ifX19
  licenseFields:
    expires_at:
      name: expires_at
      title: Expiration
      description: License Expiration
      value: "2025-05-31T00:00:00Z"
      valueType: String
      signature:
        v1: UwI4/IL6JR4K5Tw7gapvfW6+zkirfMulbAxaQqkVIAZazip+pehegNRVhHEhbM9V9EibONGBbOazipb8aQeWO2hYoN0mcQOelUxVmK7U2GFP862tyorwAPwxMg+ZbAunUsoKP4/GT+Up5bhC8UN+NgyfZFzmCo3G6TK+2tbtI/tHXN0IwFacY3TyvryAfB+6qRGpsb0efb/Wl4DNmzuo/z9qE/1HbdG/TGUdq3SEmaH4iGBSeUZMHrHmW7/fHM8DDAABi7NW8v7HGEKI467yufKPcohzim8roLl2mdLsnLq2o3J5ovsAImgXUK3ac7ymHBLdT9WRg5cuBtAWNI5oaQ==
  licenseID: 2fWGT7wAk3oTJXUrqTjFPMb9yLm
  licenseType: prod
```

There are a few useful things in there:

* Which customer this license is for, including name, a unique license ID, and
  their email.
* The customer's credentials for the Replicated registry and proxy (we used
  this earlier).
* The type of license: `prod` (representing a paid license), `dev`, `trial`, or
  `community`.
* A set of fields representing license entitlements. We'll talk about those in
  the next section.

You can use this information to customize the user experience, guard components
(e.g. don't allow persistence with trials), and tailor the install to the
license entitlements.

License Fields
==============

The license has several fields that represent specific entitlements of this
license. In Helm, they're available as a dictionary
`global.replicated.licenseFields`. Each license field is represented as a YAML
dictionary. You can add your own fields to represent your unique entitlements.
We'll do that in the next part of the lab.

Every application will have at least one field in this dictionary for the license
expiration date. If the license does not expire, the value will be blank.

```
expires_at:
  name: expires_at
  title: Expiration
  description: License Expiration
  value: "2024-06-31T00:00:00Z"
  valueType: String
  signature:
    v1: UwI4/IL6JR4K5Tw7gapvfW6+zkirfMulbAxaQqkVIAZazip+pehegNRVhHEhbM9V9EibONGBbOazipb8aQeWO2hYoN0mcQOelUxVmK7U2GFP862tyorwAPwxMg+ZbAunUsoKP4/GT+Up5bhC8UN+NgyfZFzmCo3G6TK+2tbtI/tHXN0IwFacY3TyvryAfB+6qRGpsb0efb/Wl4DNmzuo/z9qE/1HbdG/TGUdq3SEmaH4iGBSeUZMHrHmW7/fHM8DDAABi7NW8v7HGEKI467yufKPcohzim8roLl2mdLsnLq2o3J5ovsAImgXUK3ac7ymHBLdT9WRg5cuBtAWNI5oaQ==
```

Other license fields will be displayed in the same format. The name,
title, description, and type are set when you set up the field. Entitlements
can be integers, strings, text (multi-line strings), or boolean. All fields are
signed to prevent tampering. Unfortunately the built-in functions in Helm do
not include the capabilities we need to verify the signature. It's also trivial
to override the value. Even if we had the functions, it's also easy to override
the signature.

In spite of those limitations, there's still value to using the global values
in your Helm templates. You can use them to determine which features to
install, how to configure a service, or even whether to install at all. Just be
sure to also use the Replicated SDK to validate any critical license conditions
in your application code.

Limiting a Trial License
========================

One of the values we have available is the type of license that we're using for
the install. Let's use that value to limit the functionality of a Slackernews
trial.

Using the editor in the "Slackernews Chart" tab, open the file
`slackernews/templates/slackernews-deployment.yaml`.

![Editing the Slackernews Deployment](../assets/editing-the-deployment.png)

We're going to put a guard condition around the environment variables that
configure the database so that customers using a trial license can not use a
Postgres database for long-term persistence. There's already a check to see if
Postgres is enabled, so let's modify that using a helper template.

Find the line that says `{{ if eq .Values.postgres.enabled true }}` and
replace it with the following line

```
{{ if eq ( include "slackernews.persistence.enabled" .) "true" }}
```

The template we're including isn't defined, so let's add it to the
`_helpers.tpl` file with other helper templates. Open that file (also under
`slackernews/templates` and add the definition at the end.

```
{{- define "slackernews.persistence.enabled" -}}
{{- $licenseType := "prod" -}}
{{- $postgresEnabled := .Values.postgres.enabled -}}
{{- if hasKey .Values "global" -}}
  {{- if hasKey .Values.global "replicated" -}}
    {{- if hasKey .Values.global.replicated "licenseType" -}}
      {{- $licenseType = .Values.global.replicated.licenseType -}}
    {{- end -}}
  {{- end -}}
{{- end -}}
{{- and (ne $licenseType "trial") $postgresEnabled -}}
{{- end }}
```

With these additions, the template will not allow the use of the Postgres
database if the license is a trial license.

Trying it Out
=============

We've already configured Nitflex with a trial license, so let's try out our
changes. First we'll have to release them, then we'll try an install and see
what happens.

### Releasing the Updates Chart

First bump the version of the Helm chart. You can do it in the editor by
updating `Chart.yaml`, or use the following command.

```
yq -i '.version = "0.5.1"' slackernews/Chart.yaml
```

Package up the new version and release it to the three default release
channels.

```
helm package -u slackernews -d release
replicated release create --promote Unstable --chart release/slackernews-0.5.1.tgz --version 0.5.1  \
  --release-notes "Prevents persistence with trial licenses"
replicated release promote 6 Beta --version 0.5.1 \
  --release-notes "Prevents persistence with trial licenses"
replicated release promote 6 Stable --version 0.5.1 \
  --release-notes "Prevents persistence with trial licenses"
```

### Installing

Let's install the latest release as Nitflex, then check to see whether
persistence with Postgres was enabled. Since it's a good practice, let's make
sure we run our preflight checks before installing.

```
helm template oci://registry.replicated.com/[[ Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews \
  | kubectl preflight -
```

Your preflight checks should pass, so let's install. Postgres is enabled by the
default values in the chart, so we don't have to explicitly specify it on the
command line.

```
helm install --namespace slackernews --create-namespace  \
  slackernews \
  oci://registry.replicated.com/[[Instruqt-Var key="REPLICATED_APP" hostname="shell" ]]/slackernews \
  --set slackernews.domain=[[ Instruqt-Var key="SLACKERNEWS_DOMAIN" hostname="cluster" ]] \
  --set service.type=NodePort
```

Now let's check two things:

1. Did postgres get deployed?
2. Is Slackernews using it?

Let's run two commands to check this out.

```
# is postgres running
kubectl get pod -n slackernews -l app=postgres
```

You'll see that a postgres pod _is_ running. That's probably not what we
wanted, but it is what we did. The default behavior for the Slackernews chart
is to deploy Postgres and we didn't change that behavior.

What's important, though, is whether Slackernews is using it. This is where we
put our guard condition.

```
# is slackernews using it
kubectl get pod -n slackernews -l app=slackernews -o yaml | grep -A 1 DB_URI
```

You'll see output that show the DB_URI environment variable defined for the
Slackernews pod. Notice that it's using SQLlite and not Postgres.

```
- name: DB_URI
  value: sqlite:./slackernews.db
```

In a real application, you'd wouldn't want to consume resources running a
database that isn't being used. There are three manifests for Postgres in the
Slackernews chart you would want to update with the same check for whether
persistence is enabled. Let's skip that for now and move on to our own
entitlements.
</file>

<file path="protecting-your-assets/05-license-entitlements/assignment.md">
---
slug: license-entitlements
id: fxcumvzej7yc
type: challenge
title: Managing Entitlements with Custom License Fields
teaser: Customizing your customer's license for your application
notes:
- type: text
  contents: Expanding the license for your specific needs
tabs:
- id: 4vnaoq4icpw7
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 600
enhanced_loading: null
---

Each customer license has a set of attributes that supports common licensing
requirements. You can also define additional attributes that fit the needs of
your product. Let's add some fields to the Slackernews license to support
different commercial terms.

Entitlements and License Fields
===============================

The entitlements in your license are the ways you differentiate what each
customer can do with your product. Your product may be metered in certain ways,
or have different editions, or license different services it provides
independently. To capture these in the Replicated Platform we add them as new
fields on the license. In other words, license fields are the mechanism for
implementing your entitlements on the Replicated platform. Since the field
represents the entitlement, you may see the terms used almost interchangeably.

We learned a little bit about license fields in the previous sections of this
lab. We know they can be one of a handful of types and that they are included
in the Helm values the Replicated registry injects. We also know that they are
digitally signed to identify tampering. Let's learn a bit more about them
before we create new fields for the Slackernews license.

### License Fields

When you create a license field you set the following attributes:

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Field</td>
      <td>The name used to reference the field. This value cannot
      be changed.</td>
    </tr>
    <tr>
      <td>Title</td>
      <td>The display name for the field. This is how the field
      appears in the vendor portal and the admin console. You can
      change the title in the vendor portal.</td>
    </tr>
    <tr>
      <td>Type</td>
      <td>The field type. Supported formats include integer,
      string, text (multi-line string), and boolean values. This
      value cannot be changed.</td>
    </tr>
    <tr>
      <td>Default</td>
      <td>The default value for the field for both existing and
      new customers. It is a best practice to provide a default
      value when possible.</td>
    </tr>
    <tr>
      <td>Required</td>
      <td>If checked, this prevents the creation of customers
      unless this field is explicitly defined with a value.</td>
    </tr>
    <tr>
      <td>Hidden</td>
      <td>If checked, the field is not visible to your customer
      in the Replicated admin console. The field is still visible
      to you in the vendor portal. <strong>Note</strong>: The
      Hidden field is displayed only for vendors with access to
      the Replicated KOTS installer.</td>
    </tr>
  </tbody>
</table>

The type field allows you to capture different types of entitlements:

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Example Uses</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>integer</td>
      <td>
        Use this type to track specific limits in your license. If your
        customer is charged by quantities or sizes you can create an integer
        field to match that entitlement.
      </td>
    </tr>
    <tr>
      <td>string</td>
      <td>
         A string type can be used to describe more qualitative entitlements
         such as an edition. It can also be used to provide short configuration
         values that are set by your company and unique to the customer.
      </td>
    </tr>
    <tr>
      <td> text</td>
      <td>
         Text types also capture qualitative information, but in a longer form.
         These are great longer configuration values that you set specifically
         for the customer. We'll look at an interesting example below.
      </td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>
        Since each boolean value represents whether an entitlement is true or
        false, it's great for identifying capabilities that are turned on or
        off in your application based in license terms. They can also be used
        in a more structured way to represent a pricing model based in edition
        by having specific boolean fields for each edition.
      </td>
    </tr>
  </tbody>
</table>

### Another Use for License Fields

One interesting topic that often comes up is what to do when you already have a
licensing model in place. The Replicated Platform license is required for the
platform to function, but your existing license is required for your code to
work. This is another great use for Replicated license fields. You can use a
text field to provide your existing license key and use the resulting field to
provide the license to your code.

Adding Your Own Entitlements
============================

Slackernews is tightly integrated to a customer's Slack team. It becomes more
valuable with more Slack activity, and focuses on the links the team is
sharing. Those three things suggest a few different measures that Slackernews
might use to define its license entitlements.

* Members of the Slack team
* Total volume of Slack messaging
* Number of links the application is handling

Defining a good business model for Slackernews is beyond the scope of this
lab. Let's assume that members of the Slack team is the choice that Slackernews
and its stakeholders have decided on.

### Adding the License Field

You may still be logged into the Vendor Portal, if not log in again.

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

Pick "License Fields" from the menu on the left, then click either "+ Create
license field" or "Create your first license field" to add a field.

![Creating your first license field](../assets/create-a-license-field.png)

Fill in the form with the following details and click "Create".

Field: `member_count_max`<br/>
Title: `Member Count`<br/>
Type: `Integer`<br/>
Default: `100`<br/>
Required: checked<br/>

This adds our Slack team member count entitlement to the license and makes it
required on all licenses. Providing a default simplifies setup if the
entitlement has a default value in your contracts. The default will also be
used for your existing customers.

### Setting the Entitlement Value

We have three customers defined for Slackernews. Right now they all have the
default value set for the new field. But Geeglo's contract is for 1000 members
in its team. Let's update their license.

Click on "Customers" then "Geeglo" to bring up Geeglo. Bring up "Manage
Customer" to edit their license details, including your new field. The custom
fields are at the bottom, so you may need to scroll.

![Updating Geeglo's license entitlements](../assets/updating-entitlements.png)
</file>

<file path="protecting-your-assets/06-validating-license-fields/assignment.md">
---
slug: validating-license-fields
id: qswehkv2nwv6
type: challenge
title: Validating License Fields with the Replicated SDK
teaser: Calling Replicated SDK to assure customer entitlements
notes:
- type: text
  contents: Learn how to validate the entitlements we just created
tabs:
- id: 9xsnahmfmble
  title: Shell
  type: terminal
  hostname: shell
  workdir: /home/replicant
difficulty: basic
timelimit: 900
enhanced_loading: null
---

The Replicated SDK provides an in-cluster API for the Replicated Platform. One
of its core features is access to the complete customer license. We're going
to run some simple shell commands against the SDK to show how your team can
validate entitlements as part of your application.

Everything we're doing in this lab you would generally do as part of your
application code. We're using shell commands here since Replicated customers
work with many different programming languages, but everyone knows `curl` and
its friends.

The Replicated SDK
==================

The SDK runs alongside your application and enables access to the Replicated
Platform without having to make calls outside of the cluster. It in turn
connects to the vendor portal periodically to check for updates. Each update
check includes telemetry information we use to help you better understand your
customer's installation. See [Closing the Support Information Gap](https://play.instruqt.com/replicated/tracks/closing-infromation-gap) for more information.

The SDK is your mechanism for interacting with the platform from your
application. You can use it to get information about the currently installed
version, check for updates, and interact with the license. You can also send
custom metrics that supplement the default telemetry. Slackernews already
includes the Replicated SDK, so we won't need to add it to the chart. To learn
more about including it in your application, try the [Distributing Your
Application with
Replicated](https://play.instruqt.com/replicated/tracks/distributing-with-replicated)
lab.

Interacting with the SDK
========================

Since we're going to use shell commands to call the SDK, let's use the "Netshoot"
image from Nicola Kabar. This image contains a lot of network troubleshooting
tools and tools you need to work with them. That means it has `curl`, `jq`, and
other commands that make it easier to work with APIs from the command line.

```
kubectl run -n slackernews sdk-client -it --image nicolaka/netshoot
```

Let's get the license fields for the Slackernews application.

```
curl -s http://replicated:3000/api/v1/license/fields | jq .
```

This result will show the expiration date and the field you added in the
previous step of the lab.

```
{
  "expires_at": {
    "name": "expires_at",
    "title": "Expiration",
    "description": "License Expiration",
    "value": "",
    "valueType": "String",
    "signature": {
      "v1": "HlS3RIiNVGLqijbt2fvbTJyvXKNRxiMqlhS6FkJDL80NprYIc8pRQxfJRj15QtN85bJrybcqgJQfeG3mto29+EFzdic/mGhqiEp8NbMGQDMAM1UrSR7OY/9g38ljogUAUx0I9KOpdDVeXSJEAyw5GxHFrjtXYjb+5Zc4Ed4WxijmfQsUbBHQ4qWqV84x0BYAzoQ2VRiIjt7B5tWDJ2h3j8zExE98qt5RrxcaGe7Ori/6dFVUYVCUg2InCYN5oR5CiJMTgmFdgmAje368JJHVny/jxsqEd+od9rvhgF0r8ksqlR9FpzdYB4L2eA4jQd4qeJK+v7DoDNKmQCd+hJbKDA=="
    }
  },
  "member_count_max": {
    "name": "member_count_max",
    "title": "Member Count",
    "value": 100,
    "valueType": "Integer",
    "signature": {
      "v1": "d4oAFJ8trT1SVwnDa5xkURT25TD3gQwaS/urGMaAC4vOx+nKItEgI8jLySyM4ST6X+7MkJ4r4Sb9qpL9+JzeSkZA+pNGqZonebg7MaLHme3sAmw7v4+TPn+MO53fdEnVPhsZj33m6EUQvhORhxOQlVqwjVjlTbHBWidmnUaQkUr7RXLPhVL6RQJxwde6yaObifxY0Ux2BL6nbxTIwMh/yBchx8GR+gHyi6MdEBbT80P3AxzOAVPflpK2y2eX84b8wST9zHel4dL+FTPftXdqVbJB/99TIFmeiKONCi7JMq+6rGiXqgOgPg0h5YVgiS1UlLML47IrBT74Rq+EGnAE6g=="
    }
  }
}
```

To get a single field, add the field name to the URI.

```
curl -s http://replicated:3000/api/v1/license/fields/member_count_max | jq .
```

This will give you the value for the "Member Count" entitlement you added to
the license earlier.

```
{
  "name": "member_count_max",
  "title": "Max Member Count",
  "value": 100,
  "valueType": "Integer",
  "signature": {
    "v1": "ttq5sqIQbY3U+LgbqEKMQuKn5UO5r3tvHnc18Cp1JPEUGX7f6X7ZjkKO4UkTHqlyC3ZFxVc0e6FVDH02+Qw4b9biPShFIPz0wzoWdGzzuNGWVfGUIQKXYR3WXLapKaaOeeJLM6c/Z90MzW9cwxBrUVbyAzaBagBPoegL0/PpKhM2NUKpDYeDHPRHnFgANXDE+5IoB3EG4lSBivkWnioAmWZIbVcHHZTZbE9Bwdh6Tmo/J3NUFcSBUjaS23vk5y8pVQ9otefxt5DVUvZb3r6RST/xzAOLKvk0tZExRb2X/CzdmiFJct3g9sJXPMzQe/RBPUUQFtbJa+K1aHKgyK4AmA=="
  }
}
```

When you call the SDK from your code you can access the value in the `value`
field. Here in the shell we just change our `jq` expression a little bit.

```
curl -s http://replicated:3000/api/v1/license/fields/member_count_max | jq .value
```

Disconnect from the client pod for now. We'll use it again when we validate the
signed value.

```
exit
```

Verifying License Signatures
============================

You may not want to trust that value without verifying it. It's not likely your
customer is trying to circumvent your license, but it's possible that value was
changed whether out of curiosity or malice. That's why the license and its
fields are signed.

The "Settings" page for the application in the Vendor Portal shows your public
key and provides example code in a few programming languages. The key is also
available from the Vendor Portal API. Let's take a quick look. If you're not
still logged in use the following username and password to log back in.

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

Navigate to "Settings" in the left menu, then select the "Replicated SDK
signature verification" tab.

![Replicated SDK Signature Verification Instructions on the Vendor Portal](../assets/signature-verification-info.png)

To save you some time, the lab setup grabbed the public key for your
application and save it in the file `signing-key.pub`. We're going to use this
key along with the information from the SDK to verify that the member count has
not been tampered with. Copy the public key file to the `sdk-client` pod we
created earlier.

```
kubectl -n slackernews cp signing-key.pub sdk-client:signing-key.pub
```

Reconnect to the pod so we can verify the signature.

```
kubectl attach -n slackernews sdk-client -c sdk-client -i -t
```

We'll need both the signature and a hash of the member count entitlement to
validate the value is legitimate. First let's hash the value.

```
curl -s http://replicated:3000/api/v1/license/fields/member_count_max | jq -j .value | openssl dgst -md5 -binary > member_count_max.md5
```

And next the signature.

```
curl -s http://replicated:3000/api/v1/license/fields/member_count_max | jq -r .signature.v1 | base64 -d > signature.bin
```

Now we can verify that the signature is valid.

```
openssl pkeyutl -verify -in member_count_max.md5 -sigfile signature.bin -pubin -inkey signing-key.pub -pkeyopt digest:md5 -pkeyopt rsa_padding_mode:pss
```

The result `Signature Verified Successfully` confirms that the value matches
the one you set on the Vendor Portal. For your own application, you can use the
appropriate HTTP/REST client and cryptographic libraries to perform the same
validation before trusting an entitlement value.

You should also be cautious with your public key (even though it's a public
key). Making it easy for your customer to replace would re-introduce the
opportunity to tamper with the license. As an example, Slackernews compiles the
key into it's binary rather than rely on a Kubernetes secret.
</file>

<file path="protecting-your-assets/07-entitlement-metrics/assignment.md">
---
slug: entitlement-metrics
id: lmoxzfkisdgl
type: challenge
title: Using the SDK to Report Against Entitlements
teaser: |
  Providing telemetry to track entitlements
notes:
- type: text
  contents: |
    Now we'll report the current license counts to the Vendor Portal
tabs:
- id: lzrwoz9dnvgx
  title: Shell
  type: terminal
  hostname: shell
  workdir: /home/replicant
- id: 6evm0inhnqdh
  title: Vendor Portal
  type: website
  url: https://vendor.replicated.com
  new_window: true
difficulty: basic
timelimit: 600
enhanced_loading: null
---

Telemetry is a core feature of the Replicated SDK. The lab [Closing the Support
Information
Gap](https://play.instruqt.com/replicated/tracks/closing-infromation-gap)
discusses the standard telemetry. You can also send telemetry values that are
specific to your application. One use of this is to keep track of license
entitlements so you can proactively discuss upgrade opportunities with you
customers.

Like the previous section, This part of the lab also describes something you'd
usually do as part of your application code. We're using shell commands to
avoid having to use a language that not everyone is familiar with.

Sending Custom Metrics
======================

We'll continue using `curl` from the `nicolaka/netshoot` image to call the
SDK. Run a new pod with that container and connect to it.

```
kubectl run -n slackernews sdk-client -it --image nicolaka/netshoot
```

We're going to send two metrics that Slackernews could be interested in given
their user-based licensing model: daily active users and monthly active users.
We send both since the more stable monthly user makes sense from a compliance
perspective but the daily number is a useful trend. The Slackernews team can
use changes in the daily number to proactively connect with Nitflex. This can
help create a timely upsell or avoid an unexpected churn.

Your application will send metrics by posting a message to the
`/api/v1/custom-metrics` endpoint on the SDK. You can send as many metrics as
you want, but each message must contain all of your custom metrics. Each metric
is a field a `data` object, and all values must be scalar.

Let's send our two metrics, there will be no return message so let's send

```
curl -X POST -H "Content-Type: application/json" \
    -d '{"data": { "dailyUsers": 78, "monthlyUsers": 82 } }' \
  http://replicated:3000/api/v1/app/custom-metrics
```

You'll get an empty string (`""`) as a response if you've typed the command
correctly. Let's log into the vendor portal and check the metrics we've
submitted.

Viewing Your Metrics
====================

Your vendor portal login should still be active, but if your session has
expired use the following username and password to log back in.

Username: `[[ Instruqt-Var key="USERNAME" hostname="shell" ]]`<br/>
Password: `[[ Instruqt-Var key="PASSWORD" hostname="shell" ]]`

Navigate to the "Customers" page and select the single instance for your
Nitflex customer. When you pull up the instances details you'll see the metrics
you sent above the stream of telemetry events from your instance.

![Daily and monthly active user metrics in Instance Insights](../assets/user-metrics-for-instance.png)

You should also see the events for each metric near the top of the event
stream.

![Daily and monthly user events in the event stream](../assets/user-metrics-events.png)

Accessing Metrics Programmatically
==================================

You can access telemetry events using the Replicated Vendor API. This includes
the custom metrics you've sent for your entitlements. Since this something you
do as the software vendor, we'll use the Replicated CLI to run it in your local
shell. Exit the shell from your `sdk-client` pod if you haven't already done
so.

The CLI doesn't provide direct access to the event stream, but the `api`
subcommand allows us to call any API endpoint directly. Events are shown per
application, collected across all customers and instances. You can narrow down
the events you access using the following filters:

* _Date_. You can use the `before` and `after` query parameters to specify
  events before or after a specific date.
* _Customer_. The `customerIDs` filter takes a comma-delimited list of customer
  IDs (not names) and restricts the results to those customers. You can easily
  find customer IDs with the `replicated customers ls` command.
* _Event Type_. To limit your view to a specific type or types of event, use
  the `eventTypes` filter. It also takes a comma-delimited list.

Let's skip the date filter and use the other two filters to limit our event
stream to Nitflex and the two customer metrics we send for our entitlements.
The event types are the same as the keys we used when we sent the metrics:
`dailyUsers` and `monthlyUsers`.

We also need the application ID and customer ID.

```
replicated app ls
```

Copy the first column and set it in the variable `app_id`.

```
export APP_ID=[[ Instruqt-Var key="APP_ID" hostname="shell" ]]
```

Do the same thing for the customer.

```
replicated customer ls
```

Set the variable `customer_id`

```
export CUSTOMER_ID=[[ Instruqt-Var key="CUSTOMER_ID" hostname="shell" ]]
```

Now that we have everything we need, let's use the `replicated` command to see
the events we sent.

```
replicated api get /v3/app/${APP_ID}/events\?customerIDs=${CUSTOMER_ID}\&eventTypes=dailyUsers,monthlyUsers \
  | jq .
```

You'll see the full event info from your two metrics. If you get an error that
the `replicated` command was not found, make sure you exited the shell from
your pod.

```
[
  {
    "customerId": "2fmesxEDU1ZnLnyQ8lzgZoOGoPS",
    "instanceId": "8a8046a2-cac8-4637-b7b5-88d18cb35460",
    "appId": "2fmefiZM7NrzbP4pNoldpnbVpFq",
    "reportedAt": "2024-04-29T17:21:31.508",
    "fieldName": "dailyUsers",
    "isCustom": true,
    "newValue": "78",
    "previousValue": ""
  },
  {
    "customerId": "2fmesxEDU1ZnLnyQ8lzgZoOGoPS",
    "instanceId": "8a8046a2-cac8-4637-b7b5-88d18cb35460",
    "appId": "2fmefiZM7NrzbP4pNoldpnbVpFq",
    "reportedAt": "2024-04-29T17:21:31.508",
    "fieldName": "monthlyUsers",
    "isCustom": true,
    "newValue": "82",
    "previousValue": ""
  }
]
```

🏁 Finish
=========

Your now tracking Nitflex's usage against their entitlements and explored the
scope of how the Replicated platform helps you protect your assets and
intellectual property.
</file>

</files>
