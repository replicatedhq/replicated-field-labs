#!/bin/bash

if [ ! -d /root/.kube ]; then
  # generate and fetch kubeconfig for cluster
  mkdir /root/.kube
  ssh kurl-node-1 "curl https://kurl.sh/latest/tasks.sh | SUDO_USER=root bash -s generate-admin-user"
  scp kurl-node-1:root.conf /root/.kube/config
fi

# break stuff
debug-message "Reticulating Splines..."
debug-message "patch a random deployment to use a low memory limit & request"

app_slug=$(agent variable get APP_SLUG)

if [[ -z "${app_slug}" ]]; then
  fail-message "APP_SLUG could not be parsed from env"
  exit 1
fi

set +u
until [[ -n $deployment  ]] ; do
  read -r namespace deployment < <(kubectl get deployments -A --no-headers -l kots.io/app-slug="${app_slug}"  | awk '{print $1,$2}' | shuf -n1)
done
set -u

# backup resource before we edit it for later
kubectl get deployment -n "${namespace}" "${deployment}" -o json \
| jq 'del(.status,.metadata.managedFields,.metadata.annotations."kubectl.kubernetes.io/last-applied-configuration",.metadata.generation,.metadata.uid,.metadata.resourceVersion,.metadata.annotations."deployment.kubernetes.io/revision",.metadata.creationTimestamp)' \
| tee /opt/deployment_backup.json

#expose these for later
agent variable set T2_DEP_NAME "${deployment}"
agent variable set T2_DEP_NS "${namespace}"

# if the deployment doesn't have a requests object, we need to add it, otherwise replace it
if kubectl get deployment -n "${namespace}" "${deployment}" -o json | jq '.spec.template.spec.containers[0].resources.requests // empty'; then
  op=add
else
  op=replace
fi

kubectl patch deployment -n "${namespace}" "${deployment}" --type='json' -p='[{"op": '"$op"', "path": "/spec/template/spec/containers/0/resources/requests/memory", "value": "512k"}]'

if kubectl get deployment -n "${namespace}" "${deployment}" -o json | jq '.spec.template.spec.containers[0].resources.limits // empty'; then
  op=add
else
  op=replace
fi
kubectl patch deployment -n "${namespace}" "${deployment}" --type='json' -p='[{"op": '"$op"', "path": "/spec/template/spec/containers/0/resources/limits/memory", "value": "512k"}]'

# get rid of the other replicasets that could be keeping the app up
kubectl get replicasets --no-headers --sort-by='{.metadata.creationTimestamp}' | awk '{print $1}' | grep -E "^${deployment}-.+" | head -n -1 | xargs kubectl delete replicasets

sleep 60

debug-message "Mischief Managed! patched ${deployment} in ${namespace} to use a low memory limit & request"
